{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"codexctl","text":"<p>A tool for managing containerized AI coding agent projects using Podman. Provides both a CLI (<code>codexctl</code>) and a Textual TUI (<code>codextui</code>).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Project Management: Define and manage containerized AI agent projects</li> <li>Task Lifecycle: Create, run, and manage tasks with automatic workspace setup</li> <li>Multiple Agents: Support for Codex, Claude Code, Mistral Vibe, and Blablador</li> <li>Security Modes: Online and gatekeeping modes for different trust levels</li> <li>Container Layers: Efficient three-layer Docker image architecture (L0/L1/L2)</li> <li>SSH Integration: Automatic SSH key management for private Git repositories</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Podman installed and configured</li> <li>Python 3.9+</li> <li>OpenSSH client (for private git repos)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone and install\ngit clone git@github.com:sliwowitz/codexctl.git\ncd codexctl\npip install .\n\n# With TUI support\npip install '.[tui]'\n</code></pre>"},{"location":"#basic-workflow","title":"Basic Workflow","text":"<pre><code># 1. Create project directory\nmkdir -p ~/.config/codexctl/projects/myproj\n\n# 2. Create project.yml\ncat &gt; ~/.config/codexctl/projects/myproj/project.yml &lt;&lt; 'EOF'\nproject:\n  id: myproj\n  security_class: online\ngit:\n  upstream_url: https://github.com/yourorg/yourrepo.git\n  default_branch: main\nEOF\n\n# 3. Generate and build images\ncodexctl generate myproj\ncodexctl build myproj\n\n# 4. Create and run a task\ncodexctl task new myproj\ncodexctl task run-cli myproj 1\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>User Guide - Complete user documentation</li> <li>Developer Guide - Architecture and contributing</li> <li>API Reference - Auto-generated API documentation</li> </ul>"},{"location":"#license","title":"License","text":"<p>See LICENSE file.</p>"},{"location":"CONTAINER_LAYERS/","title":"Container Layers","text":"<p>Container layering in codexctl</p> <p>Overview - codexctl builds project containers in three logical layers. L0 (dev) and L1 (agent) are project\u2011agnostic and cache well; L2 is project\u2011specific.</p> <p>Layers 0. L0 \u2014 development base (codexctl-l0:)    - Based on Ubuntu 24.04 by default (override via docker.base_image).    - Installs common tooling (git, openssh-client, ripgrep, vim, etc.).    - Creates /workspace and sets WORKDIR to /workspace.    - Creates a dev user with passwordless sudo and runs containers as that user.    - Stages the init-ssh-and-repo.sh script into the image at /usr/local/bin and makes it the default CMD.    - Exposes environment defaults used by the init script:      - REPO_ROOT=/workspace      - GIT_RESET_MODE=none <ol> <li>L1 \u2014 agent images (codexctl-l1-cli:, codexctl-l1-ui:) <li>Built FROM L0.</li> <li>CLI image installs Codex, Claude Code, Mistral Vibe, and supporting tools.</li> <li>UI image installs UI dependencies and sets CMD to codexui-entry.sh.</li> <li> <p>codexui-entry.sh:</p> <ul> <li>Invokes init-ssh-and-repo.sh first (if present) to initialize SSH and the project repo in /workspace.</li> <li>Syncs the UI repo, installs node dependencies, then starts the UI server.</li> <li>If REPO_ROOT exists, cd into it so the UI starts in the project root.</li> </ul> </li> <li> <p>L2 \u2014 project images (:l2-cli, :l2-ui) <li>Built FROM the corresponding L1 agent image.</li> <li>Adds project\u2011specific defaults (CODE_REPO, SSH_KEY_NAME, GIT_BRANCH) and the user snippet.</li> <li>Optional manual dev image (:l2-dev) is built FROM L0 when requested. <li>The UI backend is configurable (Codex, Claude, or Mistral). Precedence (highest to lowest):<ol> <li>CLI flag: <code>codexctl task run-ui --backend &lt;backend&gt;</code></li> <li>Environment variable: <code>DEFAULT_AGENT</code> on the host</li> <li>Per-project config: <code>default_agent</code> in project.yml</li> <li>Global config: <code>default_agent</code> in ~/.config/codexctl/config.yml</li> <li>Default: codex</li> <li>For Claude, provide CODEXUI_CLAUDE_API_KEY (or ANTHROPIC_API_KEY / CLAUDE_API_KEY) and optional CODEXUI_CLAUDE_MODEL.</li> <li>For Mistral, provide CODEXUI_MISTRAL_API_KEY (or MISTRAL_API_KEY) and optional CODEXUI_MISTRAL_MODEL.</li> </ol> </li> <p>Build flow - codexctl generate  renders four Dockerfiles (L0/L1/L2) into the per\u2011project build directory:   - L0.Dockerfile   - L1.cli.Dockerfile   - L1.ui.Dockerfile   - L2.Dockerfile - codexctl build  executes podman builds in order:   1) codexctl-l0: FROM docker.base_image (default: Ubuntu 24.04)   2) codexctl-l1-cli: FROM codexctl-l0:   3) codexctl-l1-ui: FROM codexctl-l0:   4) :l2-cli FROM codexctl-l1-cli: (via --build-arg BASE_IMAGE=...)   5) :l2-ui FROM codexctl-l1-ui: (via --build-arg BASE_IMAGE=...)   6) Optional: :l2-dev FROM codexctl-l0: (when <code>codexctl build --dev</code> is used)   -  is derived from docker.base_image (sanitized), e.g.:     - ubuntu:24.04 \u2192 ubuntu-24.04     - nvcr.io/nvidia/nvhpc:25.9-devel-cuda13.0-ubuntu24.04 \u2192 nvcr-io-nvidia-nvhpc-25.9-devel-cuda13.0-ubuntu24.04 <p>Runtime behavior (tasks) - codexctl task run-cli starts :l2-cli; codexctl task run-ui starts :l2-ui. - Both modes:   - Mount a per\u2011task workspace directory from the host to /workspace.   - Mount a shared codex config directory to /home/dev/.codex (rw).   - Mount a shared Claude config directory to /home/dev/.claude (rw) and set CLAUDE_CONFIG_DIR=/home/dev/.claude.   - Mount a shared Mistral Vibe config directory to /home/dev/.vibe (rw).   - Optionally mount a per\u2011project SSH config directory to /home/dev/.ssh (rw) if it exists.   - Set working directory to /workspace.   - Provide env vars to the init script: REPO_ROOT, CODE_REPO, GIT_BRANCH, GIT_RESET_MODE. - The init script clones or syncs the project repository into /workspace and, if configured, warms up SSH known_hosts. <p>GPU support - GPU passthrough is opt\u2011in per project (run.gpus in project.yml). When enabled, codexctl adds the necessary Podman flags for NVIDIA GPUs.</p>"},{"location":"DEVELOPER/","title":"Developer Guide","text":"<p>This document covers internal architecture and implementation details for contributors and maintainers of codexctl.</p>"},{"location":"DEVELOPER/#container-readiness-and-log-streaming","title":"Container Readiness and Log Streaming","text":"<p>codexctl shows the initial container logs to the user when starting task containers and then automatically detaches once a \"ready\" condition is met. This improves UX but introduces dependencies that developers must be aware of when changing entry scripts or server behavior.</p>"},{"location":"DEVELOPER/#cli-mode-task-run-cli","title":"CLI Mode (task run-cli)","text":"<p>Readiness is determined from log output. The container initialization script emits marker lines: - <code>\"&gt;&gt; init complete\"</code> (from <code>resources/scripts/init-ssh-and-repo.sh</code>) - <code>\"__CLI_READY__\"</code> (echoed by the run command just before keeping the container alive)</p> <p>The host follows logs and detaches when either of these markers appears, or after 60 seconds timeout.</p> <p>If you modify the init script, ensure a stable readiness line is preserved, or update the detection in <code>src/codexctl/lib/tasks.py</code> (<code>task_run_cli</code> and <code>_stream_initial_logs</code>).</p>"},{"location":"DEVELOPER/#ui-mode-task-run-ui","title":"UI Mode (task run-ui)","text":"<p>Readiness is determined by log markers, not port probing. The host follows container logs and detaches when it sees specific startup markers from Codex UI: - Primary marker: <code>\"Codex UI (\"</code> (the main startup banner when HTTP server is ready) - Secondary marker: <code>\"Logging Codex UI activity\"</code> (log redirection message)</p> <p>This approach avoids false positives from port binding before actual server readiness. The default entry script is <code>resources/scripts/codexui-entry.sh</code> which runs <code>server.ts</code> via <code>tsx</code> or <code>ts-node</code> from the CodexUI repo.</p> <p>If the UI server changes its startup behavior or output format, you may need to adjust: - The readiness markers in <code>src/codexctl/lib/tasks.py</code> (<code>_ui_ready</code> function) - The exposed/internal port and host port mapping in <code>src/codexctl/lib/tasks.py</code> (<code>task_run_ui</code>)</p>"},{"location":"DEVELOPER/#timeout-behavior","title":"Timeout Behavior","text":"<ul> <li>CLI: detaches after readiness marker or 60s timeout</li> <li>UI: detaches after readiness marker (no timeout by default; follows logs until ready)</li> <li>Even on timeout, containers remain running in the background. Users can continue watching logs with <code>podman logs -f &lt;container&gt;</code>.</li> </ul>"},{"location":"DEVELOPER/#key-source-files","title":"Key Source Files","text":"File Purpose <code>src/codexctl/lib/tasks.py</code> Host-side logic: <code>task_run_cli</code>, <code>task_run_ui</code>, <code>_stream_initial_logs</code>, <code>_ui_ready</code> <code>src/codexctl/resources/scripts/init-ssh-and-repo.sh</code> CLI init marker, SSH setup, repo sync <code>src/codexctl/resources/scripts/codexui-entry.sh</code> UI entry script (runs the UI server) <p>Important: Changes to startup output or listening ports can affect readiness detection. Keep the readiness semantics stable or adjust codexctl's detection accordingly.</p>"},{"location":"DEVELOPER/#container-layer-architecture","title":"Container Layer Architecture","text":"<p>codexctl builds project containers in three logical layers:</p> Layer Image Name Purpose L0 <code>codexctl-l0:&lt;base-tag&gt;</code> Development base (Ubuntu 24.04, git, ssh, dev user) L1-CLI <code>codexctl-l1-cli:&lt;base-tag&gt;</code> Agent tools (Codex, Claude Code, Mistral Vibe) L1-UI <code>codexctl-l1-ui:&lt;base-tag&gt;</code> UI dependencies and entry script L2 <code>&lt;project&gt;:l2-cli</code>, <code>&lt;project&gt;:l2-ui</code> Project-specific config and user snippets <p>L0 and L1 are project-agnostic and cache well; L2 is project-specific.</p> <p>See CONTAINER_LAYERS.md for detailed documentation.</p>"},{"location":"DEVELOPER/#volume-mounts-at-runtime","title":"Volume Mounts at Runtime","text":"<p>When a task container starts, codexctl mounts:</p> Container Path Host Source Purpose <code>/workspace</code> <code>&lt;state_root&gt;/tasks/&lt;project&gt;/&lt;task&gt;/workspace</code> Per-task workspace <code>/home/dev/.codex</code> <code>&lt;envs_base&gt;/_codex-config</code> Codex credentials <code>/home/dev/.claude</code> <code>&lt;envs_base&gt;/_claude-config</code> Claude Code credentials <code>/home/dev/.vibe</code> <code>&lt;envs_base&gt;/_vibe-config</code> Mistral Vibe credentials <code>/home/dev/.blablador</code> <code>&lt;envs_base&gt;/_blablador-config</code> Blablador credentials <code>/home/dev/.ssh</code> (optional) <code>&lt;envs_base&gt;/_ssh-config-&lt;project&gt;</code> SSH keys/config <p>See SHARED_DIRS.md for detailed documentation.</p>"},{"location":"DEVELOPER/#environment-variables-set-by-codexctl","title":"Environment Variables Set by codexctl","text":""},{"location":"DEVELOPER/#core-variables-always-set","title":"Core Variables (always set)","text":"Variable Value Purpose <code>PROJECT_ID</code> Project ID from config Identify current project <code>TASK_ID</code> Numeric task ID Identify current task <code>REPO_ROOT</code> <code>/workspace</code> Init script clone target <code>CLAUDE_CONFIG_DIR</code> <code>/home/dev/.claude</code> Claude Code config location <code>GIT_RESET_MODE</code> <code>none</code> (default) Controls workspace reset behavior <code>HUMAN_GIT_NAME</code> From config or \"Nobody\" Git committer name <code>HUMAN_GIT_EMAIL</code> From config or \"nobody@localhost\" Git committer email"},{"location":"DEVELOPER/#conditional-variables-based-on-security-mode","title":"Conditional Variables (based on security mode)","text":"Variable When Set Purpose <code>CODE_REPO</code> Always Git URL (upstream or gate depending on mode) <code>GIT_BRANCH</code> Always Target branch name <code>CLONE_FROM</code> Online mode with gate Alternate clone source for faster init <code>EXTERNAL_REMOTE_URL</code> Relaxed gatekeeping Upstream URL for \"external\" remote"},{"location":"DEVELOPER/#security-modes","title":"Security Modes","text":""},{"location":"DEVELOPER/#online-mode","title":"Online Mode","text":"<ul> <li><code>CODE_REPO</code> points to upstream URL</li> <li>Container can push directly to upstream</li> <li>Git gate (if present) is used as read-only clone accelerator</li> </ul>"},{"location":"DEVELOPER/#gatekeeping-mode","title":"Gatekeeping Mode","text":"<ul> <li><code>CODE_REPO</code> points to <code>file:///git-gate/gate.git</code></li> <li>Container cannot access upstream directly</li> <li>Human review required before changes reach upstream</li> </ul> <p>See GIT_CACHE_AND_SECURITY_MODES.md for detailed documentation.</p>"},{"location":"DEVELOPER/#development-workflow","title":"Development Workflow","text":""},{"location":"DEVELOPER/#initial-setup","title":"Initial Setup","text":"<pre><code># Clone the repository\ngit clone git@github.com:sliwowitz/codexctl.git\ncd codexctl\n\n# Install all development dependencies\nmake install-dev\n</code></pre>"},{"location":"DEVELOPER/#before-you-commit","title":"Before You Commit","text":"<p>Always run the linter before committing:</p> <pre><code>make lint      # Check for issues (fast, ~1 second)\n</code></pre> <p>If linting fails, auto-fix with:</p> <pre><code>make format    # Auto-fix lint issues and format code\n</code></pre> <p>Run tests before pushing (or at least before opening a PR):</p> <pre><code>make test      # Run full test suite with coverage\n</code></pre> <p>To run both (equivalent to CI):</p> <pre><code>make check     # Runs lint + test\n</code></pre>"},{"location":"DEVELOPER/#available-make-targets","title":"Available Make Targets","text":"Command Description When to Use <code>make lint</code> Check linting and formatting Before every commit <code>make format</code> Auto-fix lint issues and format When lint fails <code>make test</code> Run tests with coverage Before pushing <code>make check</code> Run lint + test Before opening a PR <code>make docs</code> Serve documentation locally When editing docs <code>make install-dev</code> Install all dependencies Initial setup <code>make clean</code> Remove build artifacts When needed"},{"location":"DEVELOPER/#running-from-source","title":"Running from Source","text":"<pre><code># Set up environment to use example projects\nexport CODEXCTL_CONFIG_DIR=$PWD/examples\nexport CODEXCTL_STATE_DIR=$PWD/tmp/dev-runtime/var-lib-codexctl\n\n# Run CLI commands\npython -m codexctl.cli projects\npython -m codexctl.cli task new uc\npython -m codexctl.cli generate uc\npython -m codexctl.cli build uc\n\n# Run TUI\npython -m codexctl.tui\n</code></pre>"},{"location":"DEVELOPER/#ide-setup-pycharmvscode","title":"IDE Setup (PyCharm/VSCode)","text":"<ol> <li>Open the repo and set up a Python 3.12+ interpreter</li> <li>Set environment variables:</li> <li><code>CODEXCTL_CONFIG_DIR</code> = <code>/path/to/this/repo/examples</code></li> <li>Optional: <code>CODEXCTL_STATE_DIR</code> = writable path</li> <li>For PyCharm Run/Debug configuration:</li> <li>CLI: Module name = <code>codexctl.cli</code>, Parameters = <code>projects</code> (or other subcommands)</li> <li>TUI: Module name = <code>codexctl.tui</code> (no args)</li> </ol>"},{"location":"DEVELOPER/#building-wheels","title":"Building Wheels","text":"<pre><code># Build wheel\npython -m pip install --upgrade build\npython -m build\n\n# Install in development mode (editable)\npip install -e .\n</code></pre>"},{"location":"DEVELOPER/#packaging","title":"Packaging","text":"<p>See PACKAGING.md for details on: - Python packaging (pip/Poetry) - Distribution packages (deb/rpm) - FHS compliance - Runtime lookup strategy</p>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/","title":"Git Gate and Security Modes","text":"<p>This document describes the Git gate concept and the distinction between online and gatekeeping projects.</p>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#update-january-2026","title":"Update (January 2026)","text":""},{"location":"GIT_CACHE_AND_SECURITY_MODES/#terminology-change-cache-gate","title":"Terminology change: Cache \u2192 Gate","text":"<p>The \"cache\" has been renamed to \"gate\" throughout the codebase because it serves as more than just a cache - it's the central gatekeeping mechanism for controlling code flow:</p> <ul> <li><code>codexctl cache-init</code> \u2192 <code>codexctl gate-init</code></li> <li><code>cache_path</code> \u2192 <code>gate_path</code></li> <li><code>/git-cache/cache.git</code> \u2192 <code>/git-gate/gate.git</code></li> <li>Config section <code>cache:</code> \u2192 <code>gate:</code></li> </ul>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#new-features","title":"New Features","text":"<ol> <li>External remote exposure (<code>gatekeeping.expose_external_remote</code>):</li> <li> <p>Optionally add upstream URL as \"external\" remote in container</p> </li> <li> <p>Upstream polling (<code>gatekeeping.upstream_polling</code>):</p> </li> <li>TUI periodically checks if upstream has new commits using <code>git ls-remote</code> (cheap)</li> <li>Shows notification when gate is behind upstream</li> <li> <p>Configurable interval (default: 5 minutes)</p> </li> <li> <p>Auto-sync (<code>gatekeeping.auto_sync</code>):</p> </li> <li>Automatically sync gate when upstream changes detected</li> <li>Configure specific branches to auto-sync</li> <li> <p>Opt-in (default: disabled)</p> </li> <li> <p>Container staleness warning:</p> </li> <li>When <code>expose_external_remote: true</code>, container init checks if gate is behind upstream</li> <li>Shows informational message with commit counts</li> </ol>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#concept-git-gate-two-security-modes","title":"Concept: Git gate + two security modes","text":""},{"location":"GIT_CACHE_AND_SECURITY_MODES/#1-three-layers-upstream-gate-tasks","title":"1. Three layers: upstream \u2192 gate \u2192 tasks","text":"<p>For each project you conceptually have three Git layers:</p> <ol> <li>Upstream (real remote)</li> <li>The canonical repo: GitHub, GitLab, internal Git server, etc.</li> <li> <p>Example: <code>git@github.com:org/repo.git</code></p> </li> <li> <p>Local gate (host-side)</p> </li> <li>A mirror of the upstream, stored under the project's state directory:<ul> <li><code>STATE_ROOT/gate/&lt;project_id&gt;.git</code></li> </ul> </li> <li> <p>Purpose:</p> <ul> <li>Speed up clone operations (no repeated large network transfers).</li> <li>In gatekeeping setups, act as the only thing containers can access.</li> <li>Serve as a communication channel between host and container.</li> </ul> </li> <li> <p>Task working copy (container)</p> </li> <li>A regular Git working directory underneath each task's workspace.</li> <li>Each task gets its own isolated repo, seeded from either:<ul> <li>the real upstream (online mode), or</li> <li>the local gate (gatekeeping mode).</li> </ul> </li> </ol>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#2-online-vs-gatekept-projects","title":"2. Online vs Gatekept projects","text":"<p>The project's security mode controls how tasks interact with upstream vs gate:</p>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#online-projects","title":"Online projects","text":"<ul> <li>Goal: the agent behaves like a normal developer:</li> <li>It can push branches directly to upstream (subject to repo permissions).</li> <li>It can use <code>gh</code> or other GitHub/GitLab tooling normally.</li> <li>Typical behaviour:</li> <li><code>CODE_REPO</code> inside the container points to the upstream URL.</li> <li>If a local gate exists, the container will seed the initial clone from it (<code>CLONE_FROM=file:///git-gate/gate.git</code>) and then repoint <code>origin</code> to upstream.</li> <li>The gate is a performance accelerator in online mode; security comes from normal upstream auth.</li> </ul>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#gatekept-projects","title":"Gatekept projects","text":"<ul> <li>Goal: agent's changes must not reach the canonical repo directly.</li> <li>Tasks only interact with a host-side gate mirror (no direct upstream access inside the container).</li> <li>Humans (or other reviewing agents) can promote changes from the gate to upstream.</li> <li>Typical behaviour:</li> <li>Host maintains a mirror clone under the project's gate path.</li> <li>Container sees only this gate mirror as <code>CODE_REPO</code>:<ul> <li><code>CODE_REPO=file:///git-gate/gate.git</code></li> </ul> </li> <li> <p>Container never sees upstream URLs, nor any upstream credentials (unless relaxed mode).</p> </li> <li> <p>Optional SSH mount (<code>ssh.mount_in_gatekeeping</code>):</p> </li> <li>By default, containers in gatekeeping mode have no SSH access.</li> <li>Set <code>ssh.mount_in_gatekeeping: true</code> in project.yml to mount SSH credentials while still enforcing the gate-only model for the main repository.</li> <li>This is useful for repos with git submodules that need to be fetched from private repositories.</li> <li> <p>The user should ensure the SSH key does not have write access to upstream repositories.</p> </li> <li> <p>Optional external remote exposure (<code>gatekeeping.expose_external_remote</code>):</p> </li> <li>By default, containers in gatekeeping mode have no knowledge of the upstream URL.</li> <li>Set <code>gatekeeping.expose_external_remote: true</code> in project.yml to add the upstream URL as a remote named \"external\" in the container's git config.</li> <li>This is a \"relaxed gatekeeping\" mode - the container knows about the upstream, but should push to local by default.</li> <li> <p>Useful for IDE integration on the host side.</p> </li> <li> <p>Upstream polling (<code>gatekeeping.upstream_polling</code>):</p> </li> <li>TUI can periodically check if upstream has new commits.</li> <li>Uses <code>git ls-remote</code> which only queries refs (cheap, no object download).</li> <li>Shows notification in TUI when gate is behind upstream.</li> <li> <p>Configuration:     <pre><code>gatekeeping:\n  upstream_polling:\n    enabled: true           # default: true\n    interval_minutes: 5     # default: 5\n</code></pre></p> </li> <li> <p>Auto-sync (<code>gatekeeping.auto_sync</code>):</p> </li> <li>When enabled, automatically sync gate branches when upstream changes detected.</li> <li>Opt-in feature (default: disabled) to preserve explicit human control.</li> <li>Configuration:     <pre><code>gatekeeping:\n  auto_sync:\n    enabled: false\n    branches:\n      - main\n      - dev\n</code></pre></li> </ul>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#host-side-gate-lifecycle","title":"Host-side gate lifecycle","text":"<ol> <li>Generate SSH material for private upstreams (optional for public HTTPS):</li> <li><code>codexctl ssh-init &lt;project&gt;</code></li> <li>Initialize or update the gate mirror:</li> <li><code>codexctl gate-init &lt;project&gt;</code> (use <code>--force</code> to recreate)</li> <li>Run tasks:</li> <li>Online: container clones from gate then talks to upstream directly.</li> <li>Gatekept: container talks only to the gate mirror.</li> </ol>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#configuration-example","title":"Configuration Example","text":"<pre><code>project:\n  id: \"myproject\"\n  security_class: \"gatekeeping\"\n\ngit:\n  upstream_url: \"git@github.com:org/repo.git\"\n  default_branch: \"main\"\n\nssh:\n  key_name: \"id_ed25519_myproject\"\n  # mount_in_gatekeeping: true  # Enable SSH in gatekeeping mode\n\ngatekeeping:\n  # Expose upstream URL as \"external\" remote (relaxed gatekeeping)\n  expose_external_remote: true\n\n  # TUI polls upstream for changes\n  upstream_polling:\n    enabled: true\n    interval_minutes: 5\n\n  # Automatically sync gate when upstream changes\n  auto_sync:\n    enabled: false\n    branches:\n      - main\n</code></pre>"},{"location":"GIT_CACHE_AND_SECURITY_MODES/#mental-model","title":"Mental model","text":"<ul> <li>Online:</li> <li>containers trust the real upstream,</li> <li> <p>gate is a performance optimization.</p> </li> <li> <p>Gatekept:</p> </li> <li>containers trust only host-local gate mirror,</li> <li>real upstream is \"air-gapped\" behind human review,</li> <li> <p>gate serves as communication channel between host IDE and container.</p> </li> <li> <p>Relaxed Gatekept (<code>expose_external_remote: true</code>):</p> </li> <li>containers know the upstream URL, but use the gate as the default remote</li> </ul>"},{"location":"PACKAGING/","title":"Packaging","text":""},{"location":"PACKAGING/#packaging-codexctl-for-both-pip-python-and-distro-packages-debrpm","title":"Packaging codexctl for both pip (Python) and distro packages (deb/rpm)","text":"<p>This repository is set up to support two installation modes, both of which share the same single source of truth for templates and scripts:</p> <p>1) Python packaging (pip / Poetry installs) - Provides console scripts <code>codexctl</code> and <code>codexctl-tui</code>. - Ships templates and helper scripts as package resources bundled inside the wheel (single source of truth under <code>src/codexctl/resources/</code>). - Runtime loads these resources via <code>importlib.resources</code> and does not depend on external paths such as <code>/usr/share</code>.</p> <p>2) Distribution packages (deb/rpm) following FHS for config/state/binaries - Install configuration under <code>/etc/codexctl</code>. - Install binaries as standard Python console entry points under <code>/usr/bin</code>. - Writable state still lives under <code>/var/lib/codexctl</code> for system-wide installs (or the XDG data dir for user installs).</p> <p>The code follows simple Linux/XDG conventions with small environment overrides. No complex prefix probing is used.</p> <p>Key points implemented - Single source of truth for runtime assets (templates and scripts) lives under the Python package: <code>src/codexctl/resources/{templates,scripts}</code>. - Runtime loads assets exclusively via <code>importlib.resources</code> from the installed package; it does not read from <code>/usr/share/codexctl</code>. - MANIFEST.in includes all resource assets for sdist builds; <code>pyproject.toml</code> includes them as package-data in wheels.</p> <p>Recommended best practices (near-term) - Use environment overrides when running from non-standard layouts:   - <code>CODEXCTL_CONFIG_DIR</code> (points to a directory that contains <code>config.yml</code> and <code>projects/</code>)   - <code>CODEXCTL_CONFIG_FILE</code> (points directly to a <code>config.yml</code>)   - <code>CODEXCTL_STATE_DIR</code> (points to writable state root)     - For distro packages you typically do not need any overrides; config lives in <code>/etc/codexctl</code>, binaries under <code>/usr/bin</code>, and user state goes to <code>${XDG_DATA_HOME:-~/.local/share}/codexctl</code>.</p> <p>Current layout (implemented) - <code>src/codexctl/resources/templates/</code> \u2014 Dockerfile templates used to generate images. - <code>src/codexctl/resources/scripts/</code> \u2014 helper scripts staged into the build context and used by generated images. - Access via <code>importlib.resources.files(\"codexctl\") / \"resources\" / \"templates\"</code> (and <code>... / \"scripts\"</code>).</p> <p>Debian/RPM packaging notes - Use the Python build backend to produce artifacts:   - <code>python -m build</code>  # produces sdist and wheel - For Debian, <code>dh-sequence-python3</code> can use the sdist/wheel; install configuration and binaries to FHS targets:   - <code>/etc/codexctl/**</code> (config.yml, projects/*/project.yml)   - console scripts are auto-installed to <code>/usr/bin</code> by the distro tooling.   - templates and scripts are consumed directly from the installed Python package resources (no <code>/usr/share/codexctl</code> mirror required). - For RPM, use <code>%pyproject_buildrequires</code> / <code>%pyproject_wheel</code> / <code>%pyproject_install</code> macros. Map configuration files into <code>%{buildroot}%{_sysconfdir}/codexctl</code>. Runtime templates/scripts are read from the Python package.</p>"},{"location":"PACKAGING/#pip-prefix-on-debianubuntu-posix_local-scheme","title":"pip --prefix on Debian/Ubuntu (posix_local scheme)","text":"<p>On Debian/Ubuntu, pip defaults to the \"posix_local\" installation scheme when installing outside of a virtualenv and without --user. This scheme appends a trailing \"/local\" segment under the given prefix. As a result, the effective installation targets are:</p> <ul> <li>Scripts:   {prefix}/local/bin</li> <li>Purelib:   {prefix}/local/lib/pythonX.Y/dist-packages (or site-packages depending on distro)</li> </ul> <p>Implications for custom prefixes:</p> <ul> <li>If you want everything under /virt/podman/local, pass --prefix=/virt/podman (leave off the trailing /local) and let pip add \"/local\".</li> <li>Correct:  python -m pip install --prefix=/virt/podman .</li> <li> <p>Result:   /virt/podman/local/bin/codexctl and /virt/podman/local/lib/pythonX.Y/dist-packages/codexctl</p> </li> <li> <p>Do NOT include \"/local\" in the prefix yourself, otherwise you will get a nested path like /virt/podman/local/local/...</p> </li> <li>Wrong:    python -m pip install --prefix=/virt/podman/local .</li> <li>Result:   /virt/podman/local/local/bin, /virt/podman/local/local/lib/pythonX.Y/...</li> </ul> <p>Optional TUI extra and system packages</p> <ul> <li>The Textual TUI is an optional extra to avoid forcing upgrades to distro-managed packages like Pygments on Debian/Ubuntu.</li> <li>Base install (no TUI):</li> <li>python -m pip install --prefix=/virt/podman .</li> <li>With TUI:</li> <li>python -m pip install --prefix=/virt/podman '.[tui]'</li> <li>If you prefer a venv to avoid system scheme quirks:</li> <li>python -m venv .venv &amp;&amp; . .venv/bin/activate &amp;&amp; pip install '.[tui]'</li> </ul> <p>Runtime lookup strategy - Config (read-only defaults):   1) <code>CODEXCTL_CONFIG_FILE</code> (explicit file)   2) <code>${XDG_CONFIG_HOME:-~/.config}/codexctl/config.yml</code> (user override)   3) <code>sys.prefix/etc/codexctl/config.yml</code> (pip/venv data-files)   4) <code>/etc/codexctl/config.yml</code> (system default) - Projects directory (system):   1) <code>CODEXCTL_CONFIG_DIR/projects</code>   2) <code>sys.prefix/etc/codexctl/projects</code> (pip/venv data-files)   3) <code>/etc/codexctl/projects</code> - Projects directory (user):   - <code>${XDG_CONFIG_HOME:-~/.config}/codexctl/projects</code> - Shared data (templates/scripts):   - Loaded from Python package resources bundled with the wheel/install (single source of truth under <code>codexctl/resources/{templates,scripts}</code>). - Writable state (tasks/cache/build):   1) <code>CODEXCTL_STATE_DIR</code>   2) <code>${XDG_DATA_HOME:-~/.local/share}/codexctl</code></p>"},{"location":"PACKAGING/#build-directory","title":"Build directory","text":"<ul> <li>Generated artifacts default to the \"build\" directory under the writable state root, e.g. ${state_root}/build//L0.Dockerfile."},{"location":"PACKAGING/#fhs-note-about-writability","title":"FHS note about writability","text":"<ul> <li>Writable data belongs under <code>/var/lib/codexctl</code> for system installs or under <code>${XDG_DATA_HOME:-~/.local/share}/codexctl</code> for users.</li> <li>The application never writes under <code>/usr/share</code> and does not read templates/scripts from there; instead it always uses its packaged resources.</li> </ul> <p>Developer workflow - For source checkouts, you can run <code>codexctl config</code> to see which package resources are available. - You can override writable locations with:   - <code>CODEXCTL_CONFIG_DIR</code> (system config root with projects/)   - <code>CODEXCTL_STATE_DIR</code> (state root used for build dir)   - User overrides live in <code>${XDG_CONFIG_HOME:-~/.config}/codexctl</code>.</p> <p>Notes - The application does not attempt to read from <code>/usr/share/codexctl</code> at runtime; it always uses its packaged resources to avoid ambiguity.</p>"},{"location":"SHARED_DIRS/","title":"Shared Directories","text":"<p>Shared directories and mounts used by codexctl tasks</p> <p>Overview - When you run a task (CLI or UI), codexctl starts a container and mounts a small set of host directories into it. This enables:   - A host-visible workspace where the project repository is cloned (/workspace)   - Shared credentials/config for Codex under /home/dev/.codex   - Shared credentials/config for Claude Code under /home/dev/.claude   - Shared credentials/config for Mistral Vibe under /home/dev/.vibe   - Shared credentials/config for Blablador (OpenCode) under /home/dev/.blablador   - Optional per\u2011project SSH configuration under /home/dev/.ssh (read\u2011write)</p> <p>Per\u2011task workspace (required) - Host path: /tasks///workspace   - Created automatically by codexctl when the task runs   - Mounted as: :/workspace:Z - Purpose: The project repository is cloned or synced here by init-ssh-and-repo.sh. Because this path lives under the task\u2019s directory on the host, you can inspect, edit, or back it up from the host. <p>Shared envs base directory (configurable) - Base dir (default): /var/lib/codexctl/envs   - Can be overridden in the global config file (codexctl-config.yml):     envs:       base_dir: /var/lib/codexctl/envs - Under this base, four subdirectories may be used:   1) _codex-config (required; created automatically if missing)      - Mounted as: /_codex-config \u2192 /home/dev/.codex:Z (read\u2011write)      - Purpose: Shared credentials/config used by Codex-enabled tools inside the containers.   2) _claude-config (required; created automatically if missing)      - Mounted as: /_claude-config \u2192 /home/dev/.claude:Z (read\u2011write)      - Purpose: Shared credentials/config used by Claude Code in CLI mode.      - Note: codexctl sets CLAUDE_CONFIG_DIR=/home/dev/.claude inside containers.   3) _vibe-config (required; created automatically if missing)      - Mounted as: /_vibe-config \u2192 /home/dev/.vibe:Z (read\u2011write)      - Purpose: Shared credentials/config used by Mistral Vibe (CLI + UI).   4) _blablador-config (required; created automatically if missing)      - Mounted as: /_blablador-config \u2192 /home/dev/.blablador:Z (read\u2011write)      - Purpose: Shared credentials/config used by Blablador (OpenCode wrapper) inside the containers.   5) _ssh-config- (optional)      - Mounted as: /_ssh-config- \u2192 /home/dev/.ssh:Z (read\u2011write)      - Purpose: If your project uses private git URLs (e.g. git@github.com:...), provide SSH keys and config here so the container can fetch the repository. <p>Expected contents of the optional SSH config directory - Directory: /ssh-config- - Files:   - Private/public key pair for the project (e.g. id_ed25519, id_ed25519_.pub)   - config file with host definitions and IdentityFile entries - Permissions: The directory is mounted read\u2011write to /home/dev/.ssh in the container. The init script will use the keys and config directly and, if available, warm up known_hosts for github.com only when the project's code repo is hosted on GitHub. - Key selection: The init script relies on SSH_KEY_NAME if provided in the image/env, but your config file can also refer to the correct IdentityFile. <p>How to create this directory automatically - Use the helper command:   - codexctl ssh-init  [--key-type ed25519|rsa][--key-name NAME] [--force] - What it does:   - Resolves the target directory for  as:     - If /project.yml sets ssh.host_dir \u2192 use it; otherwise     - /_ssh-config-   - Generates an SSH keypair (default: ed25519) and writes a default SSH config:     - A global section applied to all hosts:       - Host *       -   IdentitiesOnly yes       -   StrictHostKeyChecking accept-new       -   IdentityFile        - This prevents interactive host\u2011key prompts (agents are non\u2011interactive) and ensures the same key is used by default for all hosts.     - A host section for github.com with User git (inherits IdentityFile from Host *).   - The SSH config is rendered from a template. You can provide your own template via project.yml \u2192 ssh.config_template.     - Supported tokens in the template: {{IDENTITY_FILE}}, {{KEY_NAME}}, {{PROJECT_ID}}     - If not provided, a built-in template is used (see src/codexctl/resources/templates/ssh_config.template).   - Prints the resulting paths. Use the .pub key to register a deploy key or add it to your Git host. <p>SELinux and mount flags - codexctl uses the :Z flag for all volume mounts to ensure correct SELinux labeling. The SSH directory is mounted with :Z for read\u2011write access.</p> <p>Git identity configuration - codexctl automatically configures git author and committer identities inside containers to identify AI-generated commits. - Git Author: Set to the AI agent that created the commit (Codex, Claude, or Mistral Vibe) - Git Committer: Set to human credentials (configurable per project) - For CLI mode: Git identity is set via environment variables in the command aliases for each agent:   - <code>codex</code> \u2192 Author: \"Codex codex@openai.com\", Committer: human credentials   - <code>claude</code> \u2192 Author: \"Claude noreply@anthropic.com\", Committer: human credentials   - <code>vibe</code> \u2192 Author: \"Mistral Vibe vibe@mistral.ai\", Committer: human credentials   - Each agent's alias sets its own git author, allowing multiple agents to coexist in the same container - For UI mode: Git identity is set in the entry script based on the default agent (configured via <code>DEFAULT_AGENT</code> env var, <code>default_agent</code> in config, or <code>--backend</code> CLI flag):   - <code>codex</code> \u2192 Author: \"Codex codex@openai.com\", Committer: human credentials   - <code>claude</code> \u2192 Author: \"Claude noreply@anthropic.com\", Committer: human credentials   - <code>mistral</code> \u2192 Author: \"Mistral Vibe vibe@mistral.ai\", Committer: human credentials   - Unknown backends default to Author: \"AI Agent ai-agent@localhost\", Committer: human credentials - Human credentials configuration (checked in order):   1. Per-project: <code>human_name</code> and <code>human_email</code> in the <code>git:</code> section of <code>project.yml</code>   2. Global codexctl config: <code>human_name</code> and <code>human_email</code> in the <code>git:</code> section of <code>~/.config/codexctl/config.yml</code>   3. Global git config: <code>git config --global user.name</code> and <code>git config --global user.email</code>   4. Defaults: \"Nobody nobody@localhost\" - Email addresses for Codex, Claude, and Mistral are GitHub-recognized and will display with avatars in commit history. - This approach ensures commits show both the AI agent (author) and the human supervisor (committer).</p> <p>Quick reference (runtime mounts) - /workspace              \u2190 /tasks///workspace:Z - /home/dev/.codex        \u2190 /_codex-config:Z - /home/dev/.claude       \u2190 /_claude-config:Z - /home/dev/.vibe         \u2190 /_vibe-config:Z - /home/dev/.blablador    \u2190 /_blablador-config:Z - /home/dev/.ssh (optional) \u2190 /_ssh-config-:Z <p>How codexctl discovers these paths - state_root: Determined by CODEXCTL_STATE_DIR or defaults (root: /var/lib/codexctl; user: ${XDG_DATA_HOME:-~/.local/share}/codexctl). - envs_base: Set in codexctl-config.yml under envs.base_dir; defaults to /var/lib/codexctl/envs if unspecified.</p> <p>Minimal setup to run tasks 1) Ensure codexctl can write to the state root (or set CODEXCTL_STATE_DIR accordingly). 2) Optionally create the envs base dir (codexctl will create these directories automatically if missing):    - sudo mkdir -p /var/lib/codexctl/envs/_codex-config    - sudo mkdir -p /var/lib/codexctl/envs/_claude-config    - sudo mkdir -p /var/lib/codexctl/envs/_vibe-config    - sudo mkdir -p /var/lib/codexctl/envs/_blablador-config 3) If using private git repositories for a project :    - sudo mkdir -p /var/lib/codexctl/envs/_ssh-config-    - Place SSH keys and config there (see above). Keys must match your repo host. <p>Notes - The SSH directory is optional. Public HTTPS repos do not require it. - The .codex directory is mounted read\u2011write and should contain any credentials/config required by Codex tooling. - The .claude directory is mounted read\u2011write and should contain any credentials/config required by Claude Code. - The .vibe directory is mounted read\u2011write and should contain any credentials/config required by Mistral Vibe. - The .blablador directory is mounted read\u2011write and should contain any credentials/config required by Blablador (OpenCode). - Both CLI and UI containers mount the same paths and start with the working directory set to /workspace.</p> <p>See also - Run <code>codexctl config</code> to see the resolved envs base dir and other important paths.</p>"},{"location":"USAGE/","title":"codexctl User Guide","text":"<p>A prefix-/XDG-aware tool to manage containerized AI agent projects using Podman. Provides a CLI (<code>codexctl</code>) and a Textual TUI (<code>codextui</code>).</p>"},{"location":"USAGE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Runtime Locations</li> <li>Global Configuration</li> <li>From Zero to First Run</li> <li>GPU Passthrough</li> <li>Tips</li> <li>FAQ</li> </ul>"},{"location":"USAGE/#installation","title":"Installation","text":""},{"location":"USAGE/#via-pip","title":"Via pip","text":"<pre><code># Build from source\npython -m pip install --upgrade build\npython -m build\npip install dist/codexctl-*.whl\n\n# Or install directly (editable for development)\npip install -e .\n\n# With TUI support\npip install '.[tui]'\n</code></pre> <p>After install, you should have console scripts: <code>codexctl</code>, <code>codexctl-tui</code>, <code>codextui</code></p>"},{"location":"USAGE/#bash-completion","title":"Bash Completion","text":"<p>Bash completion is powered by argcomplete.</p> <ul> <li>If your system has bash-completion installed (common on most distros), completion is enabled automatically</li> <li>Manual setup:</li> <li>One-time system-wide: <code>sudo activate-global-python-argcomplete</code></li> <li>Per-shell: <code>eval \"$(register-python-argcomplete codexctl)\"</code></li> <li>Per-user: add to <code>~/.bashrc</code>: <code>eval \"$(register-python-argcomplete codexctl)\"</code></li> <li>Zsh users:   <pre><code>autoload -U bashcompinit &amp;&amp; bashcompinit\neval \"$(register-python-argcomplete --shell zsh codexctl)\"\n</code></pre></li> </ul>"},{"location":"USAGE/#custom-install-paths","title":"Custom Install Paths","text":"<p>User-local (no root): <pre><code>pip install --user .\n# Binaries go to ~/.local/bin (ensure it's on PATH)\n</code></pre></p> <p>Custom prefix (Debian/Ubuntu):</p> <p>On Debian/Ubuntu, pip uses the <code>posix_local</code> scheme which inserts <code>/local</code> under the prefix.</p> <pre><code># Correct - let pip add /local:\npip install --prefix=/virt/podman .\n# Result: /virt/podman/local/bin/codexctl\n\n# Wrong - don't add /local yourself:\npip install --prefix=/virt/podman/local .\n# Result: /virt/podman/local/local/bin/codexctl\n</code></pre> <p>Virtual environment (recommended): <pre><code>python -m venv .venv &amp;&amp; . .venv/bin/activate &amp;&amp; pip install .\n</code></pre></p>"},{"location":"USAGE/#runtime-locations","title":"Runtime Locations","text":""},{"location":"USAGE/#configprojects","title":"Config/Projects","text":"Install Type Path Root <code>/etc/codexctl/projects</code> User <code>~/.config/codexctl/projects</code> Override <code>CODEXCTL_CONFIG_DIR=/path/to/config</code>"},{"location":"USAGE/#state-writable-tasks-build-gate","title":"State (writable: tasks, build, gate)","text":"Install Type Path Root <code>/var/lib/codexctl</code> User <code>${XDG_DATA_HOME:-~/.local/share}/codexctl</code> Override <code>CODEXCTL_STATE_DIR=/path/to/state</code>"},{"location":"USAGE/#global-configuration","title":"Global Configuration","text":"<p>The tool looks for a global config file in this order (first found wins):</p> <ol> <li><code>${XDG_CONFIG_HOME:-~/.config}/codexctl/config.yml</code> (user override)</li> <li><code>sys.prefix/etc/codexctl/config.yml</code> (pip/venv installs)</li> <li><code>/etc/codexctl/config.yml</code> (system default)</li> </ol>"},{"location":"USAGE/#example-config","title":"Example Config","text":"<p>Copy from <code>examples/codexctl-config.yml</code>: <pre><code>mkdir -p ~/.config/codexctl\ncp examples/codexctl-config.yml ~/.config/codexctl/config.yml\n</code></pre></p>"},{"location":"USAGE/#minimum-settings","title":"Minimum Settings","text":"<pre><code>ui:\n  base_port: 7860           # Default port for UI mode\n\npaths:\n  user_projects_root: ~/.config/codexctl/projects\n  state_root: ~/.local/share/codexctl\n  build_root: ~/.local/share/codexctl/build\n\ngit:\n  human_name: \"Your Name\"\n  human_email: \"your@email.com\"\n</code></pre>"},{"location":"USAGE/#from-zero-to-first-run","title":"From Zero to First Run","text":""},{"location":"USAGE/#prerequisites","title":"Prerequisites","text":"<ul> <li>Podman installed and working</li> <li>OpenSSH client tools (ssh, ssh-keygen) for private Git over SSH</li> </ul>"},{"location":"USAGE/#step-1-create-project-directory","title":"Step 1: Create Project Directory","text":"<pre><code>mkdir -p ~/.config/codexctl/projects/myproj\n</code></pre>"},{"location":"USAGE/#step-2-create-projectyml","title":"Step 2: Create project.yml","text":"<pre><code># ~/.config/codexctl/projects/myproj/project.yml\nproject:\n  id: myproj\n  security_class: online    # or \"gatekeeping\" for restricted mode\n\ngit:\n  upstream_url: git@github.com:yourorg/yourrepo.git  # or https://...\n  default_branch: main\n\n# Optional: SSH hints for containers\nssh:\n  key_name: id_ed25519_myproj  # matches key created by ssh-init\n\n# Optional: Docker include snippet\ndocker:\n  user_snippet_file: user.dockerinclude\n</code></pre>"},{"location":"USAGE/#step-3-optional-docker-include-snippet","title":"Step 3: (Optional) Docker Include Snippet","text":"<p>Create <code>~/.config/codexctl/projects/myproj/user.dockerinclude</code>: <pre><code>RUN apt-get update &amp;&amp; apt-get install -y ripgrep jq &amp;&amp; rm -rf /var/lib/apt/lists/*\n</code></pre></p> <p>This text is pasted near the end of your project image (L2) Dockerfile.</p>"},{"location":"USAGE/#step-4-generate-dockerfiles","title":"Step 4: Generate Dockerfiles","text":"<pre><code>codexctl generate myproj\n</code></pre>"},{"location":"USAGE/#step-5-build-images","title":"Step 5: Build Images","text":"<pre><code>codexctl build myproj\n\n# Optional: build a dev image from L0 as well\ncodexctl build myproj --dev\n</code></pre>"},{"location":"USAGE/#step-6-initialize-ssh-for-private-repos","title":"Step 6: Initialize SSH (for private repos)","text":"<pre><code>codexctl ssh-init myproj\n</code></pre> <p>This creates: - An ed25519 keypair named <code>id_ed25519_myproj</code> - A default SSH config with:   - <code>IdentitiesOnly yes</code>   - <code>StrictHostKeyChecking accept-new</code> (avoids interactive prompts)   - <code>IdentityFile &lt;generated_private_key&gt;</code>   - Host github.com section with <code>User git</code></p> <p>Use the printed <code>.pub</code> key to add a deploy key on your Git host.</p> <p>Advanced: Customize SSH config via template in <code>project.yml</code>: <pre><code>ssh:\n  config_template: ssh_config.template  # relative or absolute path\n</code></pre> Supported tokens: <code>{{IDENTITY_FILE}}</code>, <code>{{KEY_NAME}}</code>, <code>{{PROJECT_ID}}</code></p>"},{"location":"USAGE/#step-7-create-and-run-a-task","title":"Step 7: Create and Run a Task","text":"<pre><code># Create a new task\ncodexctl task new myproj\n# Output: Created task 1 for project myproj\n\n# List tasks\ncodexctl task list myproj\n\n# Run in CLI mode (headless agent)\ncodexctl task run-cli myproj 1\n\n# Or run in UI mode (web interface)\ncodexctl task run-ui myproj 1 --backend codex\n</code></pre>"},{"location":"USAGE/#ui-mode-configuration","title":"UI Mode Configuration","text":"Backend API Key Environment Variable Optional Model Variable codex (uses OpenAI from codex config) - claude <code>CODEXUI_CLAUDE_API_KEY</code> or <code>ANTHROPIC_API_KEY</code> or <code>CLAUDE_API_KEY</code> <code>CODEXUI_CLAUDE_MODEL</code> mistral <code>CODEXUI_MISTRAL_API_KEY</code> or <code>MISTRAL_API_KEY</code> <code>CODEXUI_MISTRAL_MODEL</code>"},{"location":"USAGE/#gpu-passthrough","title":"GPU Passthrough","text":"<p>GPU passthrough is a per-project opt-in feature (disabled by default).</p>"},{"location":"USAGE/#enable-in-projectyml","title":"Enable in project.yml","text":"<pre><code>run:\n  gpus: all   # or true\n</code></pre>"},{"location":"USAGE/#requirements","title":"Requirements","text":"<ul> <li>NVIDIA drivers installed on host</li> <li><code>nvidia-container-toolkit</code> with Podman integration</li> <li>A CUDA/NVIDIA-capable base image (e.g., NVIDIA HPC SDK or CUDA)</li> </ul> <p>Set the base image in <code>project.yml</code>: <pre><code>docker:\n  base_image: nvcr.io/nvidia/nvhpc:25.9-devel-cuda13.0-ubuntu24.04\n</code></pre></p> <p>When enabled, codexctl adds: - <code>--device nvidia.com/gpu=all</code> - <code>NVIDIA_VISIBLE_DEVICES=all</code> - <code>NVIDIA_DRIVER_CAPABILITIES=all</code></p>"},{"location":"USAGE/#tips","title":"Tips","text":"<ul> <li>Show resolved paths: <code>codexctl config</code></li> <li>Where envs live: <code>/var/lib/codexctl/envs</code> (or as configured under <code>envs.base_dir</code>)</li> <li>Shared directories: See SHARED_DIRS.md</li> <li>Security modes: See GIT_CACHE_AND_SECURITY_MODES.md</li> </ul>"},{"location":"USAGE/#faq","title":"FAQ","text":""},{"location":"USAGE/#how-do-i-install-with-a-custom-prefix","title":"How do I install with a custom prefix?","text":"<p>See Custom Install Paths above.</p>"},{"location":"USAGE/#where-are-templates-and-scripts-stored","title":"Where are templates and scripts stored?","text":"<p>Loaded from Python package resources bundled with the wheel (under <code>codexctl/resources/</code>). The application never reads from <code>/usr/share</code>.</p>"},{"location":"USAGE/#how-do-i-enable-the-tui","title":"How do I enable the TUI?","text":"<pre><code>pip install 'codexctl[tui]'\n</code></pre> <p>Then run: <code>codexctl-tui</code> or <code>codextui</code></p>"},{"location":"USAGE/#how-do-i-package-for-debianrpm","title":"How do I package for Debian/RPM?","text":"<p>See PACKAGING.md.</p>"},{"location":"USAGE/#see-also","title":"See Also","text":"<ul> <li>Developer Guide - Internal architecture and contributor docs</li> <li>Shared Directories - Volume mounts and SSH configuration</li> <li>Container Layers - Docker image architecture</li> <li>Security Modes - Online vs gatekeeping modes</li> </ul>"},{"location":"brainstorming/TODO_AGENT_HELPERS/","title":"TODO: Agent Helpers (Non\u2011repo Project Context)","text":"<p>This document captures a proposed convention for keeping agent-specific project context and long-term \u201cmemory\u201d out of the Git repository, while still making it consistently available inside containers.</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#goals","title":"Goals","text":"<ul> <li>Keep the checked-out repo root at <code>/workspace</code> for maximum compatibility with Codex / Claude Code / Vibe CLIs.</li> <li>Store agent-owned files outside the repo (not committed, not mixed with source code).</li> <li>Make project context durable across tasks (persistent \u201cmemory\u201d), while allowing per-task overrides.</li> <li>Standardize where reference code and runbooks live so agents can reliably find them.</li> </ul>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#proposed-container-layout","title":"Proposed container layout","text":"<p>The container has a single project repo at <code>/workspace</code> and a single agent context root at <code>/agent</code>.</p> <pre><code>/workspace/                 # Git repo root (what the agent edits)\n/agent/                     # Non-repo agent context (mounted/generated)\n  INSTRUCTIONS.md           # Project/container runbook (persistent)\n  TASK.md                   # Task-specific instructions (ephemeral)\n  memory/                   # Long-term memory (persistent, many small files)\n    00-index.md\n    architecture.md\n    conventions.md\n    pitfalls.md\n    decisions.md\n  runbooks/                 # Operational playbooks (persistent)\n    build-and-test.md\n    release.md\n    migrations.md\n    debugging.md\n  reference/                # Optional read-only reference code (persistent)\n    README.md               # What this is, how to use it\n    ...                     # Zips expanded here, snapshots, rewrites, etc.\n  skills/                   # Optional agent skills/playbooks (persistent)\n    ...                     # Format/tooling is agent-dependent\n  artifacts/                # Optional scratch outputs (ephemeral or persistent)\n    ...                     # Logs, repro notes, generated reports\n</code></pre> <p>Notes: - Prefer many small files in <code>/agent/memory/</code> rather than one huge file. - Keep <code>/agent/reference/</code> read-only by convention; treat it like docs/examples, not a build input.</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#what-goes-where","title":"What goes where","text":""},{"location":"brainstorming/TODO_AGENT_HELPERS/#mounted-from-the-host-shared-folders-persistent-across-tasks","title":"Mounted from the host (shared folders; persistent across tasks)","text":"<p>Recommended to mount: - <code>/agent/memory/</code> (long-term memory store) - <code>/agent/runbooks/</code> (project playbooks; \u201chow to operate this project\u201d) - <code>/agent/reference/</code> (optional, especially if large or shared across tasks) - <code>/agent/skills/</code> (optional; if you curate skills outside the image) - <code>/agent/INSTRUCTIONS.md</code> (optional; if you want to edit per-project container guidance without rebuilding)</p> <p>Should generally NOT be mounted from host: - Secrets themselves (API keys, tokens). Use agent-specific homes for auth material (e.g. <code>~/.claude</code>, <code>~/.vibe/.env</code>, <code>~/.codex</code>) or env vars injected by the runtime.</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#generated-by-the-task-runner-ephemeral-per-run","title":"Generated by the task runner (ephemeral per run)","text":"<p>Recommended to generate/overwrite: - <code>/agent/TASK.md</code> (acceptance criteria, scope limits, links, constraints for this run) - <code>/agent/artifacts/</code> (if you want per-run outputs; can also be mounted if you want to keep them)</p> <p>If you want to support \u201cextra instructions\u201d flags in a TUI/CLI, materialize them into <code>/agent/TASK.md</code> so all agents consume the same interface.</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#provided-by-the-project-dockerfile-image-defaults","title":"Provided by the project Dockerfile (image defaults)","text":"<p>Recommended to bake into the image: - Create the <code>/agent/</code> directory structure (so paths always exist). - Provide empty placeholders (<code>/agent/TASK.md</code>, <code>/agent/memory/00-index.md</code>, etc.) to reduce conditional logic. - Provide a minimal <code>/agent/INSTRUCTIONS.md</code> (generic container basics) if you don\u2019t mount a project-specific one.</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#how-to-direct-each-agent-to-agent","title":"How to \u201cdirect\u201d each agent to <code>/agent</code>","text":""},{"location":"brainstorming/TODO_AGENT_HELPERS/#codex-cli","title":"Codex CLI","text":"<p>Codex can\u2019t \u201cimport\u201d other Markdown files the way Claude can; the simplest pattern is to instruct it (via <code>~/.codex/AGENTS.md</code> or <code>~/.codex/AGENTS.override.md</code>) to always read <code>/agent/*</code> before doing work.</p> <p>Recommended approach: - Keep auth/config in <code>~/.codex/</code> (global). - Add a global rule in <code>~/.codex/AGENTS.md</code>:   - \u201cBefore doing any work, read <code>/agent/INSTRUCTIONS.md</code>, <code>/agent/TASK.md</code> (if present), and the relevant files under <code>/agent/memory/</code> and <code>/agent/runbooks/</code>.\u201d</p> <p>If you want per-project automation without changing the global file, have the task runner generate <code>~/.codex/AGENTS.override.md</code> for the container/session (note: it replaces the base file at the Codex-home level).</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#claude-code","title":"Claude Code","text":"<p>Claude supports importing additional files from <code>CLAUDE.md</code> using <code>@/path/to/file</code> syntax.</p> <p>Recommended approach: - Keep auth/config in <code>~/.claude/</code> (global). - In <code>~/.claude/CLAUDE.md</code>, import the project context:   - <code>@/agent/INSTRUCTIONS.md</code>   - <code>@/agent/TASK.md</code>   - Optionally <code>@/agent/memory/00-index.md</code> (which can in turn reference the recommended memory files).</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#mistral-vibe","title":"Mistral Vibe","text":"<p>Vibe loads user instructions from <code>~/.vibe/instructions.md</code> (and can also use <code>./.vibe/instructions.md</code> when a folder is \u201ctrusted\u201d).</p> <p>Recommended approach: - Keep auth/config in <code>~/.vibe/</code> (global). - Mount or symlink <code>~/.vibe/instructions.md</code> to <code>/agent/VIBE_INSTRUCTIONS.md</code> (or directly to <code>/agent/INSTRUCTIONS.md</code>), and include a short bootstrap:   - \u201cAt the start of each task, read <code>/agent/INSTRUCTIONS.md</code> and <code>/agent/TASK.md</code>, then consult <code>/agent/memory/</code> and <code>/agent/runbooks/</code> as needed.\u201d</p>"},{"location":"brainstorming/TODO_AGENT_HELPERS/#conventions-for-agentmemory","title":"Conventions for <code>/agent/memory/</code>","text":"<p>Suggested file set (adjust per project): - <code>00-index.md</code>: quick table-of-contents, what to update, \u201cmemory hygiene\u201d rules - <code>architecture.md</code>: high-level system map - <code>conventions.md</code>: coding/testing conventions and \u201cpreferred commands\u201d - <code>pitfalls.md</code>: known sharp edges and time-sinks - <code>decisions.md</code>: short decision log (agent-facing; separate from repo ADRs if desired)</p> <p>Keep each file short and focused; prefer updating index links over growing a single page indefinitely.</p>"},{"location":"brainstorming/per-task-context-isolation/","title":"Per-Task Context Isolation","text":""},{"location":"brainstorming/per-task-context-isolation/#problem-statement","title":"Problem Statement","text":"<p>The shared <code>~/.claude</code>, <code>~/.codex</code>, and <code>~/.vibe</code> directories serve dual purposes: 1. Authentication - API credentials that must be shared across all tasks 2. Context/Sessions - Conversation history that ideally should be scoped per-task</p> <p>Currently, all containers mount workspace at <code>/workspace</code>, so Claude Code stores all session history in <code>~/.claude/projects/-workspace/</code> regardless of which project or task created it. This creates two issues:</p> <ul> <li>When multiple tasks run concurrently, their contexts are interleaved with no way to determine which task created which session</li> <li>When browsing context history, sessions from unrelated projects/tasks add noise</li> </ul>"},{"location":"brainstorming/per-task-context-isolation/#requirements","title":"Requirements","text":"<ol> <li>Authentication must remain shared - Agents need to stay authenticated across all tasks</li> <li>Contexts should be attributable to tasks - Either physically isolated or mapped via metadata</li> <li>Context import within same project - Allow importing contexts from one task to another (same project only)</li> <li>Cleanup policy:</li> <li>For physical isolation: Archive contexts when task is deleted</li> <li>For logical isolation: No deletion needed, rely on filtering</li> </ol>"},{"location":"brainstorming/per-task-context-isolation/#design-options","title":"Design Options","text":""},{"location":"brainstorming/per-task-context-isolation/#option-1-overlayfs-not-recommended","title":"Option 1: OverlayFS (Not Recommended)","text":"<p>Use Linux OverlayFS to create a layered view: - Lower layer (read-only): Shared auth from <code>_claude-config/</code> - Upper layer (read-write): Per-task directory for new files - Merged view: Mounted as <code>~/.claude</code> in container</p> <p>Why not recommended: Requires root privileges or fuse-overlayfs setup. Complex to configure reliably with rootless podman.</p>"},{"location":"brainstorming/per-task-context-isolation/#option-2-per-task-directories-with-copied-auth-recommended-for-physical-isolation","title":"Option 2: Per-Task Directories with Copied Auth (Recommended for Physical Isolation)","text":"<p>Create separate config directories per task, with authentication files copied from global location.</p>"},{"location":"brainstorming/per-task-context-isolation/#architecture","title":"Architecture","text":"<pre><code>/var/lib/codexctl/envs/\n\u251c\u2500\u2500 _claude-config/                    # Global auth (source of truth)\n\u2502   \u251c\u2500\u2500 .credentials.json\n\u2502   \u2514\u2500\u2500 settings.json\n\u251c\u2500\u2500 _claude-config-myproject-1/        # Task 1's isolated config\n\u2502   \u251c\u2500\u2500 .credentials.json              # Copied from global\n\u2502   \u251c\u2500\u2500 settings.json                  # Copied from global\n\u2502   \u2514\u2500\u2500 projects/-workspace/           # Task 1's sessions only\n\u2502       \u2514\u2500\u2500 abc123.jsonl\n\u251c\u2500\u2500 _claude-config-myproject-2/        # Task 2's isolated config\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 _claude-archive/                   # Archived contexts from deleted tasks\n    \u2514\u2500\u2500 myproject-1/\n        \u2514\u2500\u2500 projects/-workspace/\n            \u2514\u2500\u2500 abc123.jsonl\n</code></pre>"},{"location":"brainstorming/per-task-context-isolation/#implementation","title":"Implementation","text":"<p>New helper function in <code>tasks.py</code>: <pre><code>AGENT_AUTH_FILES = {\n    \"claude\": [\".credentials.json\", \"settings.json\", \"statsig\"],\n    \"codex\": [\"auth.json\", \"settings.json\"],\n    \"vibe\": [\".env\"],\n    \"blablador\": [\"config.json\"],\n}\n\ndef _setup_task_config_dir(base_name: str, project_id: str, task_id: str, auth_files: list[str]) -&gt; Path:\n    \"\"\"Create per-task config directory with auth files copied from global.\"\"\"\n    envs_base = get_envs_base_dir()\n    global_config = envs_base / f\"_{base_name}-config\"\n    task_config = envs_base / f\"_{base_name}-config-{project_id}-{task_id}\"\n\n    task_config.mkdir(parents=True, exist_ok=True)\n\n    for auth_file in auth_files:\n        src = global_config / auth_file\n        dst = task_config / auth_file\n        if src.exists() and not dst.exists():\n            shutil.copy2(src, dst) if src.is_file() else shutil.copytree(src, dst)\n\n    return task_config\n</code></pre></p> <p>Modify volume mounts in <code>_build_task_env_and_volumes()</code>: <pre><code># Instead of:\nvolumes.append(f\"{envs_base}/_claude-config:/home/dev/.claude:Z\")\n\n# Use:\nclaude_task_dir = _setup_task_config_dir(\"claude\", project.id, task_id, AGENT_AUTH_FILES[\"claude\"])\nvolumes.append(f\"{claude_task_dir}:/home/dev/.claude:Z\")\n</code></pre></p>"},{"location":"brainstorming/per-task-context-isolation/#cli-commands","title":"CLI Commands","text":"<ul> <li><code>codexctl task contexts &lt;project&gt; &lt;task&gt;</code> - List sessions created by task</li> <li><code>codexctl task import-context &lt;project&gt; &lt;dest-task&gt; --from &lt;source-task&gt;</code> - Copy sessions</li> <li><code>codexctl auth sync [--project &lt;project&gt;]</code> - Sync auth files after credential update</li> </ul>"},{"location":"brainstorming/per-task-context-isolation/#proscons","title":"Pros/Cons","text":"Pros Cons Perfect isolation, no race conditions Auth files copied (need sync on update) Works with rootless podman Slight disk overhead Easy to debug (just ls the directory) More directories to manage Simple implementation"},{"location":"brainstorming/per-task-context-isolation/#option-3-auditcgroup-tracking-not-recommended","title":"Option 3: Audit/Cgroup Tracking (Not Recommended)","text":"<p>Use Linux audit subsystem (<code>auditd</code>) or timestamp correlation to track which files were created during a task's execution window.</p> <p>Why not recommended: - <code>auditd</code> requires root privileges - Timestamp-based correlation has race conditions with concurrent tasks - <code>inotifywait</code> doesn't work reliably with host-mounted directories in rootless podman due to user namespace isolation</p>"},{"location":"brainstorming/per-task-context-isolation/#option-4-in-container-file-monitor-recommended-for-logical-isolation","title":"Option 4: In-Container File Monitor (Recommended for Logical Isolation)","text":"<p>Track context file creation from within the container, writing the mapping to a host-mounted location.</p>"},{"location":"brainstorming/per-task-context-isolation/#architecture_1","title":"Architecture","text":"<pre><code>/var/lib/codexctl/envs/\n\u2514\u2500\u2500 _claude-config/                    # Shared (unchanged)\n    \u2514\u2500\u2500 projects/-workspace/           # All sessions live here\n        \u251c\u2500\u2500 abc123.jsonl               # Created by task 1\n        \u2514\u2500\u2500 def456.jsonl               # Created by task 2\n\n&lt;tasks_root&gt;/myproject/1/workspace/\n\u2514\u2500\u2500 .codexctl/\n    \u2514\u2500\u2500 task-1-contexts.log            # Maps task 1 to its sessions\n        # 2025-01-10T14:30:00 abc123.jsonl\n\n&lt;tasks_root&gt;/myproject/2/workspace/\n\u2514\u2500\u2500 .codexctl/\n    \u2514\u2500\u2500 task-2-contexts.log            # Maps task 2 to its sessions\n        # 2025-01-10T15:45:00 def456.jsonl\n</code></pre>"},{"location":"brainstorming/per-task-context-isolation/#implementation_1","title":"Implementation","text":"<p>New script <code>monitor-context-files.sh</code> (runs in container): <pre><code>#!/bin/bash\nWATCH_DIR=\"/home/dev/.claude/projects/-workspace\"\nLOG_FILE=\"/workspace/.codexctl/task-${TASK_ID}-contexts.log\"\nPOLL_INTERVAL=2\n\nmkdir -p \"$(dirname \"$LOG_FILE\")\" \"$WATCH_DIR\"\nBASELINE=$(find \"$WATCH_DIR\" -maxdepth 1 -name \"*.jsonl\" -type f 2&gt;/dev/null | sort)\n\nwhile true; do\n    sleep \"$POLL_INTERVAL\"\n    CURRENT=$(find \"$WATCH_DIR\" -maxdepth 1 -name \"*.jsonl\" -type f 2&gt;/dev/null | sort)\n    NEW=$(comm -13 &lt;(echo \"$BASELINE\") &lt;(echo \"$CURRENT\"))\n\n    if [[ -n \"$NEW\" ]]; then\n        while IFS= read -r file; do\n            [[ -n \"$file\" ]] &amp;&amp; echo \"$(date -Iseconds) $(basename \"$file\")\" &gt;&gt; \"$LOG_FILE\"\n        done &lt;&lt;&lt; \"$NEW\"\n        BASELINE=\"$CURRENT\"\n    fi\ndone\n</code></pre></p> <p>Start monitor in <code>init-ssh-and-repo.sh</code>: <pre><code>if [[ -n \"${TASK_ID:-}\" ]]; then\n    nohup monitor-context-files.sh &gt;/dev/null 2&gt;&amp;1 &amp;\nfi\n</code></pre></p> <p>Host-side parsing in <code>tasks.py</code>: <pre><code>def get_task_contexts(project_id: str, task_id: str) -&gt; list[str]:\n    \"\"\"Read context log and return list of session IDs for this task.\"\"\"\n    log_file = project.tasks_root / task_id / \"workspace\" / \".codexctl\" / f\"task-{task_id}-contexts.log\"\n    if not log_file.exists():\n        return []\n\n    sessions = []\n    for line in log_file.read_text().splitlines():\n        parts = line.split(maxsplit=1)\n        if len(parts) == 2:\n            sessions.append(parts[1].replace(\".jsonl\", \"\"))\n    return sessions\n</code></pre></p>"},{"location":"brainstorming/per-task-context-isolation/#cli-commands_1","title":"CLI Commands","text":"<ul> <li><code>codexctl task contexts &lt;project&gt; &lt;task&gt;</code> - List sessions mapped to task</li> <li><code>codexctl task import-context &lt;project&gt; &lt;dest-task&gt; --from &lt;source-task&gt;</code> - Add source task's sessions to dest's mapping</li> <li><code>codexctl context list [--project &lt;project&gt;] [--task &lt;task&gt;]</code> - List all contexts with optional filtering</li> </ul>"},{"location":"brainstorming/per-task-context-isolation/#proscons_1","title":"Pros/Cons","text":"Pros Cons No mount structure changes Polling-based (2s delay) Shared storage, easy cross-task access Requires monitor process No deletion needed, just filter Log file in workspace Simplest container setup"},{"location":"brainstorming/per-task-context-isolation/#comparison","title":"Comparison","text":"Aspect Option 2: Per-Task Dirs Option 4: In-Container Monitor Isolation type Physical Logical (mapping) Race conditions None None (polling) Privileges required None None Container setup changes Medium Low Auth handling Copied per-task Shared globally Cleanup on delete Archive contexts No cleanup needed Cross-task recall Copy files Filter by mapping Complexity Low-Medium Low-Medium"},{"location":"brainstorming/per-task-context-isolation/#recommendation","title":"Recommendation","text":"<ul> <li>Option 2 if you want clean physical separation and easy inspection/debugging</li> <li>Option 4 if you want minimal changes and prefer shared storage with logical filtering</li> </ul> <p>Both options work well with rootless podman and have no race conditions.</p>"},{"location":"brainstorming/per-task-context-isolation/#files-to-modify","title":"Files to Modify","text":""},{"location":"brainstorming/per-task-context-isolation/#option-2","title":"Option 2","text":"<ul> <li><code>/workspace/src/codexctl/lib/tasks.py</code> - Add <code>_setup_task_config_dir()</code>, modify volumes, add archival</li> <li><code>/workspace/src/codexctl/cli/main.py</code> - Add CLI commands</li> </ul>"},{"location":"brainstorming/per-task-context-isolation/#option-4","title":"Option 4","text":"<ul> <li><code>/workspace/src/codexctl/resources/scripts/monitor-context-files.sh</code> - New script</li> <li><code>/workspace/src/codexctl/resources/scripts/init-ssh-and-repo.sh</code> - Start monitor</li> <li><code>/workspace/src/codexctl/lib/tasks.py</code> - Add <code>get_task_contexts()</code></li> <li><code>/workspace/src/codexctl/cli/main.py</code> - Add CLI commands</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>codexctl<ul> <li>cli<ul> <li>main</li> </ul> </li> <li>lib<ul> <li>auth</li> <li>config</li> <li>docker</li> <li>fs</li> <li>git_gate</li> <li>images</li> <li>paths</li> <li>podman</li> <li>projects</li> <li>ssh</li> <li>tasks</li> <li>template_utils</li> </ul> </li> <li>tui<ul> <li>app</li> <li>widgets</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/codexctl/","title":"codexctl","text":""},{"location":"reference/codexctl/#codexctl","title":"<code>codexctl</code>","text":"<p>codexctl package.</p> <p>Modules: - codexctl.cli: CLI entry point package (codexctl) - codexctl.tui: Text UI entry point package (codexctl-tui / codextui) - codexctl.tui.widgets: TUI widgets - codexctl.lib: Core library package (auth, config, docker, git_gate, projects, ssh, tasks) - codexctl.lib.paths: Base path helpers</p>"},{"location":"reference/codexctl/cli/","title":"cli","text":""},{"location":"reference/codexctl/cli/#codexctl.cli","title":"<code>cli</code>","text":"<p>codexctl CLI package.</p>"},{"location":"reference/codexctl/cli/main/","title":"main","text":""},{"location":"reference/codexctl/cli/main/#codexctl.cli.main","title":"<code>main</code>","text":""},{"location":"reference/codexctl/lib/","title":"lib","text":""},{"location":"reference/codexctl/lib/#codexctl.lib","title":"<code>lib</code>","text":"<p>Shared library modules for codexctl.</p>"},{"location":"reference/codexctl/lib/auth/","title":"auth","text":""},{"location":"reference/codexctl/lib/auth/#codexctl.lib.auth","title":"<code>auth</code>","text":""},{"location":"reference/codexctl/lib/auth/#codexctl.lib.auth.codex_auth","title":"<code>codex_auth(project_id)</code>","text":"<p>Run codex login inside the L2 CLI container to authenticate the Codex CLI.</p> <p>This command: - Spins up a temporary L2 CLI container for the project (L2 has the codex CLI) - Mounts the shared codex config directory (/home/dev/.codex) - Forwards port 1455 from the container to localhost for OAuth callback - Sets up socat port forwarding for port 1455 (required for rootless podman) - Runs <code>codex login</code> interactively - The authentication persists in the shared .codex folder</p> <p>The user can press Ctrl+C to stop the container after authentication is complete.</p> Source code in <code>src/codexctl/lib/auth.py</code> <pre><code>def codex_auth(project_id: str) -&gt; None:\n    \"\"\"Run codex login inside the L2 CLI container to authenticate the Codex CLI.\n\n    This command:\n    - Spins up a temporary L2 CLI container for the project (L2 has the codex CLI)\n    - Mounts the shared codex config directory (/home/dev/.codex)\n    - Forwards port 1455 from the container to localhost for OAuth callback\n    - Sets up socat port forwarding for port 1455 (required for rootless podman)\n    - Runs `codex login` interactively\n    - The authentication persists in the shared .codex folder\n\n    The user can press Ctrl+C to stop the container after authentication is complete.\n    \"\"\"\n    _check_podman()\n\n    project = load_project(project_id)\n\n    # Shared env mounts - we only need the codex config directory\n    envs_base = get_envs_base_dir()\n    codex_host_dir = envs_base / \"_codex-config\"\n    _ensure_dir_writable(codex_host_dir, \"Codex config\")\n\n    container_name = f\"{project.id}-auth-codex\"\n    _cleanup_existing_container(container_name)\n\n    # Build the podman run command\n    # - Interactive with TTY for codex login\n    # - Port 1455 is the default port used by `codex login` for OAuth callback\n    # - Mount codex config dir for persistent auth\n    # - Use L2 CLI image (which has the codex CLI installed)\n    # - Run setup-codex-auth.sh script which handles port forwarding and codex login\n    cmd = [\n        \"podman\",\n        \"run\",\n        \"--rm\",\n        \"-it\",\n        \"-p\",\n        \"127.0.0.1:1455:1455\",\n        \"-v\",\n        f\"{codex_host_dir}:/home/dev/.codex:Z\",\n        \"--name\",\n        container_name,\n        project_cli_image(project.id),\n        \"setup-codex-auth.sh\",\n    ]\n    cmd[3:3] = _podman_userns_args()\n\n    print(\"Authenticating Codex for project:\", project.id)\n    print()\n    print(\"This will set up port forwarding (using socat) and open a browser for authentication.\")\n    print(\"After completing authentication, press Ctrl+C to stop the container.\")\n    print()\n    print(\"$\", \" \".join(map(str, cmd)))\n    print()\n\n    try:\n        subprocess.run(cmd, check=True)\n    except subprocess.CalledProcessError as e:\n        # Exit code 130 is typically Ctrl+C (SIGINT), which is expected\n        if e.returncode == 130:\n            print(\"\\nAuthentication container stopped.\")\n        else:\n            raise SystemExit(f\"Auth failed: {e}\")\n    except KeyboardInterrupt:\n        print(\"\\nAuthentication interrupted.\")\n        # Best-effort cleanup\n        subprocess.run(\n            [\"podman\", \"rm\", \"-f\", container_name],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            check=False,\n        )\n</code></pre>"},{"location":"reference/codexctl/lib/auth/#codexctl.lib.auth.claude_auth","title":"<code>claude_auth(project_id)</code>","text":"<p>Set up Claude API key for CLI inside the L2 CLI container.</p> <p>This command: - Spins up a temporary L2 CLI container for the project (L2 has the claude CLI) - Mounts the shared claude config directory (/home/dev/.claude) - Runs an interactive shell where the user can enter their Claude API key - The API key persists in the shared .claude folder</p> <p>Claude stores the API key in ~/.claude/config.json or similar configuration.</p> Source code in <code>src/codexctl/lib/auth.py</code> <pre><code>def claude_auth(project_id: str) -&gt; None:\n    \"\"\"Set up Claude API key for CLI inside the L2 CLI container.\n\n    This command:\n    - Spins up a temporary L2 CLI container for the project (L2 has the claude CLI)\n    - Mounts the shared claude config directory (/home/dev/.claude)\n    - Runs an interactive shell where the user can enter their Claude API key\n    - The API key persists in the shared .claude folder\n\n    Claude stores the API key in ~/.claude/config.json or similar configuration.\n    \"\"\"\n    _check_podman()\n\n    project = load_project(project_id)\n\n    # Shared env mounts - we only need the claude config directory\n    envs_base = get_envs_base_dir()\n    claude_host_dir = envs_base / \"_claude-config\"\n    _ensure_dir_writable(claude_host_dir, \"Claude config\")\n\n    container_name = f\"{project.id}-auth-claude\"\n    _cleanup_existing_container(container_name)\n\n    # Build the podman run command\n    # - Interactive with TTY for API key entry\n    # - Mount claude config dir for persistent auth\n    # - Use L2 CLI image (which has claude CLI installed)\n    cmd = [\n        \"podman\",\n        \"run\",\n        \"--rm\",\n        \"-it\",\n        \"-v\",\n        f\"{claude_host_dir}:/home/dev/.claude:Z\",\n        \"--name\",\n        container_name,\n        project_cli_image(project.id),\n        \"bash\",\n        \"-c\",\n        \"echo 'Enter your Claude API key (get one at https://console.anthropic.com/settings/keys):' &amp;&amp; \"\n        \"read -r -p 'ANTHROPIC_API_KEY=' api_key &amp;&amp; \"\n        \"mkdir -p ~/.claude &amp;&amp; \"\n        'echo \\'{\"api_key\": \"$api_key\"}\\' &gt; ~/.claude/config.json &amp;&amp; '\n        \"echo &amp;&amp; echo 'API key saved to ~/.claude/config.json' &amp;&amp; \"\n        \"echo 'You can now use claude in task containers.'\",\n    ]\n    cmd[3:3] = _podman_userns_args()\n\n    print(\"Authenticating Claude for project:\", project.id)\n    print()\n    print(\"You will be prompted to enter your Claude API key.\")\n    print(\"Get your API key at: https://console.anthropic.com/settings/keys\")\n    print()\n    print(\"$\", \" \".join(map(str, cmd)))\n    print()\n\n    try:\n        subprocess.run(cmd, check=True)\n    except subprocess.CalledProcessError as e:\n        if e.returncode == 130:\n            print(\"\\nAuthentication container stopped.\")\n        else:\n            raise SystemExit(f\"Auth failed: {e}\")\n    except KeyboardInterrupt:\n        print(\"\\nAuthentication interrupted.\")\n        subprocess.run(\n            [\"podman\", \"rm\", \"-f\", container_name],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            check=False,\n        )\n</code></pre>"},{"location":"reference/codexctl/lib/auth/#codexctl.lib.auth.mistral_auth","title":"<code>mistral_auth(project_id)</code>","text":"<p>Set up Mistral API key for Vibe CLI inside the L2 CLI container.</p> <p>This command: - Spins up a temporary L2 CLI container for the project (L2 has mistral-vibe) - Mounts the shared vibe config directory (/home/dev/.vibe) - Runs an interactive shell where the user can run <code>vibe</code> to trigger   the API key prompt, or manually create ~/.vibe/.env - The API key persists in the shared .vibe folder</p> <p>Mistral Vibe stores the API key in ~/.vibe/.env as MISTRAL_API_KEY=. Source code in <code>src/codexctl/lib/auth.py</code> <pre><code>def mistral_auth(project_id: str) -&gt; None:\n    \"\"\"Set up Mistral API key for Vibe CLI inside the L2 CLI container.\n\n    This command:\n    - Spins up a temporary L2 CLI container for the project (L2 has mistral-vibe)\n    - Mounts the shared vibe config directory (/home/dev/.vibe)\n    - Runs an interactive shell where the user can run `vibe` to trigger\n      the API key prompt, or manually create ~/.vibe/.env\n    - The API key persists in the shared .vibe folder\n\n    Mistral Vibe stores the API key in ~/.vibe/.env as MISTRAL_API_KEY=&lt;key&gt;.\n    \"\"\"\n    _check_podman()\n\n    project = load_project(project_id)\n\n    # Shared env mounts - we only need the vibe config directory\n    envs_base = get_envs_base_dir()\n    vibe_host_dir = envs_base / \"_vibe-config\"\n    _ensure_dir_writable(vibe_host_dir, \"Vibe config\")\n\n    container_name = f\"{project.id}-auth-mistral\"\n    _cleanup_existing_container(container_name)\n\n    # Build the podman run command\n    # - Interactive with TTY for API key entry\n    # - Mount vibe config dir for persistent auth\n    # - Use L2 CLI image (which has mistral-vibe installed)\n    cmd = [\n        \"podman\",\n        \"run\",\n        \"--rm\",\n        \"-it\",\n        \"-v\",\n        f\"{vibe_host_dir}:/home/dev/.vibe:Z\",\n        \"--name\",\n        container_name,\n        project_cli_image(project.id),\n        \"bash\",\n        \"-c\",\n        \"echo 'Enter your Mistral API key (get one at https://console.mistral.ai/api-keys):' &amp;&amp; \"\n        \"read -r -p 'MISTRAL_API_KEY=' api_key &amp;&amp; \"\n        \"mkdir -p ~/.vibe &amp;&amp; \"\n        'echo \"MISTRAL_API_KEY=$api_key\" &gt; ~/.vibe/.env &amp;&amp; '\n        \"echo &amp;&amp; echo 'API key saved to ~/.vibe/.env' &amp;&amp; \"\n        \"echo 'You can now use vibe in task containers.'\",\n    ]\n    cmd[3:3] = _podman_userns_args()\n\n    print(\"Authenticating Mistral Vibe for project:\", project.id)\n    print()\n    print(\"You will be prompted to enter your Mistral API key.\")\n    print(\"Get your API key at: https://console.mistral.ai/api-keys\")\n    print()\n    print(\"$\", \" \".join(map(str, cmd)))\n    print()\n\n    try:\n        subprocess.run(cmd, check=True)\n    except subprocess.CalledProcessError as e:\n        if e.returncode == 130:\n            print(\"\\nAuthentication container stopped.\")\n        else:\n            raise SystemExit(f\"Auth failed: {e}\")\n    except KeyboardInterrupt:\n        print(\"\\nAuthentication interrupted.\")\n        subprocess.run(\n            [\"podman\", \"rm\", \"-f\", container_name],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            check=False,\n        )\n</code></pre>"},{"location":"reference/codexctl/lib/auth/#codexctl.lib.auth.blablador_auth","title":"<code>blablador_auth(project_id)</code>","text":"<p>Set up Blablador API key for OpenCode inside the L2 CLI container.</p> <p>This command: - Spins up a temporary L2 CLI container for the project (L2 has OpenCode + blablador wrapper) - Mounts the shared blablador config directory (/home/dev/.blablador) - Runs an interactive shell where the user can enter their Blablador API key - The API key persists in the shared .blablador folder</p> <p>Blablador stores the API key in ~/.blablador/config.json as {\"api_key\": \"\"}. Source code in <code>src/codexctl/lib/auth.py</code> <pre><code>def blablador_auth(project_id: str) -&gt; None:\n    \"\"\"Set up Blablador API key for OpenCode inside the L2 CLI container.\n\n    This command:\n    - Spins up a temporary L2 CLI container for the project (L2 has OpenCode + blablador wrapper)\n    - Mounts the shared blablador config directory (/home/dev/.blablador)\n    - Runs an interactive shell where the user can enter their Blablador API key\n    - The API key persists in the shared .blablador folder\n\n    Blablador stores the API key in ~/.blablador/config.json as {\"api_key\": \"&lt;key&gt;\"}.\n    \"\"\"\n    _check_podman()\n\n    project = load_project(project_id)\n\n    # Shared env mounts - we only need the blablador config directory\n    envs_base = get_envs_base_dir()\n    blablador_host_dir = envs_base / \"_blablador-config\"\n    _ensure_dir_writable(blablador_host_dir, \"Blablador config\")\n\n    container_name = f\"{project.id}-auth-blablador\"\n    _cleanup_existing_container(container_name)\n\n    # Build the podman run command\n    # - Interactive with TTY for API key entry\n    # - Mount blablador config dir for persistent auth\n    # - Use L2 CLI image (which has OpenCode + blablador wrapper installed)\n    cmd = [\n        \"podman\",\n        \"run\",\n        \"--rm\",\n        \"-it\",\n        \"-v\",\n        f\"{blablador_host_dir}:/home/dev/.blablador:Z\",\n        \"--name\",\n        container_name,\n        project_cli_image(project.id),\n        \"bash\",\n        \"-c\",\n        \"echo 'Enter your Blablador API key (get one at https://codebase.helmholtz.cloud/-/user_settings/personal_access_tokens):' &amp;&amp; \"\n        \"read -r -p 'BLABLADOR_API_KEY=' api_key &amp;&amp; \"\n        \"mkdir -p ~/.blablador &amp;&amp; \"\n        'echo \"{\\\\\"api_key\\\\\": \\\\\"$api_key\\\\\"}\" &gt; ~/.blablador/config.json &amp;&amp; '\n        \"echo &amp;&amp; echo 'API key saved to ~/.blablador/config.json' &amp;&amp; \"\n        \"echo 'You can now use blablador in task containers.'\",\n    ]\n    cmd[3:3] = _podman_userns_args()\n\n    print(\"Authenticating Blablador for project:\", project.id)\n    print()\n    print(\"You will be prompted to enter your Blablador API key.\")\n    print(\n        \"Get your API key at: https://codebase.helmholtz.cloud/-/user_settings/personal_access_tokens\"\n    )\n    print()\n    print(\"$\", \" \".join(map(str, cmd)))\n    print()\n\n    try:\n        subprocess.run(cmd, check=True)\n    except subprocess.CalledProcessError as e:\n        if e.returncode == 130:\n            print(\"\\nAuthentication container stopped.\")\n        else:\n            raise SystemExit(f\"Auth failed: {e}\")\n    except KeyboardInterrupt:\n        print(\"\\nAuthentication interrupted.\")\n        subprocess.run(\n            [\"podman\", \"rm\", \"-f\", container_name],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            check=False,\n        )\n</code></pre>"},{"location":"reference/codexctl/lib/config/","title":"config","text":""},{"location":"reference/codexctl/lib/config/#codexctl.lib.config","title":"<code>config</code>","text":""},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.get_prefix","title":"<code>get_prefix()</code>","text":"<p>Minimal prefix helper used primarily for pip/venv installs.</p> <p>Order: - If CODEXCTL_PREFIX is set, use it. - Otherwise, use sys.prefix.</p> <p>Note: Do not use this for config/data discovery - see the dedicated helpers below which follow common Linux/XDG conventions.</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def get_prefix() -&gt; Path:\n    \"\"\"\n    Minimal prefix helper used primarily for pip/venv installs.\n\n    Order:\n    - If CODEXCTL_PREFIX is set, use it.\n    - Otherwise, use sys.prefix.\n\n    Note: Do not use this for config/data discovery - see the dedicated\n    helpers below which follow common Linux/XDG conventions.\n    \"\"\"\n    env = os.environ.get(\"CODEXCTL_PREFIX\")\n    if env:\n        return Path(env).expanduser().resolve()\n    return Path(sys.prefix).resolve()\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.config_root","title":"<code>config_root()</code>","text":"<p>System projects directory. Uses FHS/XDG via codexctl.lib.paths.</p> <p>Behavior: - If the base config directory contains a 'projects' subdirectory, use it. - Otherwise, treat the base config directory itself as the projects root.</p> <p>This makes development convenient when CODEXCTL_CONFIG_DIR points directly to a folder that already contains per-project subdirectories (like ./examples).</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def config_root() -&gt; Path:\n    \"\"\"\n    System projects directory. Uses FHS/XDG via codexctl.lib.paths.\n\n    Behavior:\n    - If the base config directory contains a 'projects' subdirectory, use it.\n    - Otherwise, treat the base config directory itself as the projects root.\n\n    This makes development convenient when CODEXCTL_CONFIG_DIR points directly\n    to a folder that already contains per-project subdirectories (like ./examples).\n    \"\"\"\n    base = _config_root_base().resolve()\n    proj_dir = base / \"projects\"\n    return proj_dir if proj_dir.is_dir() else base\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.global_config_search_paths","title":"<code>global_config_search_paths()</code>","text":"<p>Return the ordered list of paths that will be checked for global config.</p> <p>Behavior matches global_config_path(): - If CODEXCTL_CONFIG_FILE is set, only that single path is considered. - Otherwise, check in order:     1) ${XDG_CONFIG_HOME:-~/.config}/codexctl/config.yml     2) sys.prefix/etc/codexctl/config.yml     3) /etc/codexctl/config.yml</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def global_config_search_paths() -&gt; list[Path]:\n    \"\"\"Return the ordered list of paths that will be checked for global config.\n\n    Behavior matches global_config_path():\n    - If CODEXCTL_CONFIG_FILE is set, only that single path is considered.\n    - Otherwise, check in order:\n        1) ${XDG_CONFIG_HOME:-~/.config}/codexctl/config.yml\n        2) sys.prefix/etc/codexctl/config.yml\n        3) /etc/codexctl/config.yml\n    \"\"\"\n    env_file = os.environ.get(\"CODEXCTL_CONFIG_FILE\")\n    if env_file:\n        return [Path(env_file).expanduser().resolve()]\n\n    xdg_home = os.environ.get(\"XDG_CONFIG_HOME\")\n    user_cfg = (Path(xdg_home) if xdg_home else Path.home() / \".config\") / \"codexctl\" / \"config.yml\"\n    sp_cfg = Path(sys.prefix) / \"etc\" / \"codexctl\" / \"config.yml\"\n    etc_cfg = Path(\"/etc/codexctl/config.yml\")\n    return [user_cfg, sp_cfg, etc_cfg]\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.global_config_path","title":"<code>global_config_path()</code>","text":"<p>Global config file path (resolved based on search paths).</p> <p>Resolution order (first existing wins, except explicit override is returned even if missing to make intent visible to the user): - CODEXCTL_CONFIG_FILE env (returned as-is) - ${XDG_CONFIG_HOME:-~/.config}/codexctl/config.yml (user override) - sys.prefix/etc/codexctl/config.yml (pip wheels) - /etc/codexctl/config.yml (system default) If none exist, return the last path (/etc/codexctl/config.yml).</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def global_config_path() -&gt; Path:\n    \"\"\"Global config file path (resolved based on search paths).\n\n    Resolution order (first existing wins, except explicit override is returned even\n    if missing to make intent visible to the user):\n    - CODEXCTL_CONFIG_FILE env (returned as-is)\n    - ${XDG_CONFIG_HOME:-~/.config}/codexctl/config.yml (user override)\n    - sys.prefix/etc/codexctl/config.yml (pip wheels)\n    - /etc/codexctl/config.yml (system default)\n    If none exist, return the last path (/etc/codexctl/config.yml).\n    \"\"\"\n    candidates = global_config_search_paths()\n    # If CODEXCTL_CONFIG_FILE is set, candidates has a single element and we\n    # want to return it even if it doesn't exist.\n    if len(candidates) == 1:\n        return candidates[0]\n\n    for c in candidates:\n        if c.is_file():\n            return c.resolve()\n    return candidates[-1]\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.state_root","title":"<code>state_root()</code>","text":"<p>Writable state directory for tasks/cache/build.</p> <p>Precedence: - Environment variable CODEXCTL_STATE_DIR (handled first) - If set in global config (paths.state_root), use it. - Otherwise, use codexctl.lib.paths.state_root() (FHS/XDG handling).</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def state_root() -&gt; Path:\n    \"\"\"Writable state directory for tasks/cache/build.\n\n    Precedence:\n    - Environment variable CODEXCTL_STATE_DIR (handled first)\n    - If set in global config (paths.state_root), use it.\n    - Otherwise, use codexctl.lib.paths.state_root() (FHS/XDG handling).\n    \"\"\"\n    # Environment override should always win\n    env = os.environ.get(\"CODEXCTL_STATE_DIR\")\n    if env:\n        return Path(env).expanduser().resolve()\n\n    try:\n        cfg = load_global_config()\n        cfg_path = (cfg.get(\"paths\", {}) or {}).get(\"state_root\")\n        if cfg_path:\n            return Path(cfg_path).expanduser().resolve()\n    except Exception:\n        # Be resilient to any config read error\n        pass\n    return _state_root_base().resolve()\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.build_root","title":"<code>build_root()</code>","text":"<p>Directory for build artifacts (generated Dockerfiles, etc.).</p> <p>Resolution order: - Global config: paths.build_root - Otherwise: state_root()/build</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def build_root() -&gt; Path:\n    \"\"\"\n    Directory for build artifacts (generated Dockerfiles, etc.).\n\n    Resolution order:\n    - Global config: paths.build_root\n    - Otherwise: state_root()/build\n    \"\"\"\n    # Global config preferred\n    try:\n        cfg = load_global_config()\n        paths_cfg = cfg.get(\"paths\", {}) or {}\n        br = paths_cfg.get(\"build_root\")\n        if br:\n            return Path(br).expanduser().resolve()\n    except Exception:\n        pass\n\n    sr = state_root()\n    return (sr / \"build\").resolve()\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.get_envs_base_dir","title":"<code>get_envs_base_dir()</code>","text":"<p>Return the base directory for shared env mounts (codex/ssh).</p> <p>Global config (codexctl-config.yml):   envs:     base_dir: /var/lib/codexctl/envs</p> <p>Default: /var/lib/codexctl/envs</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def get_envs_base_dir() -&gt; Path:\n    \"\"\"Return the base directory for shared env mounts (codex/ssh).\n\n    Global config (codexctl-config.yml):\n      envs:\n        base_dir: /var/lib/codexctl/envs\n\n    Default: /var/lib/codexctl/envs\n    \"\"\"\n    cfg = load_global_config()\n    envs_cfg = cfg.get(\"envs\", {}) or {}\n    base = envs_cfg.get(\"base_dir\", \"/var/lib/codexctl/envs\")\n    return Path(str(base)).expanduser().resolve()\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.get_global_human_name","title":"<code>get_global_human_name()</code>","text":"<p>Return git.human_name from global config, or None if not set.</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def get_global_human_name() -&gt; str | None:\n    \"\"\"Return git.human_name from global config, or None if not set.\"\"\"\n    cfg = load_global_config()\n    git_cfg = cfg.get(\"git\", {}) or {}\n    return git_cfg.get(\"human_name\")\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.get_global_human_email","title":"<code>get_global_human_email()</code>","text":"<p>Return git.human_email from global config, or None if not set.</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def get_global_human_email() -&gt; str | None:\n    \"\"\"Return git.human_email from global config, or None if not set.\"\"\"\n    cfg = load_global_config()\n    git_cfg = cfg.get(\"git\", {}) or {}\n    return git_cfg.get(\"human_email\")\n</code></pre>"},{"location":"reference/codexctl/lib/config/#codexctl.lib.config.get_global_default_agent","title":"<code>get_global_default_agent()</code>","text":"<p>Return default_agent from global config, or None if not set.</p> Source code in <code>src/codexctl/lib/config.py</code> <pre><code>def get_global_default_agent() -&gt; str | None:\n    \"\"\"Return default_agent from global config, or None if not set.\"\"\"\n    cfg = load_global_config()\n    return cfg.get(\"default_agent\")\n</code></pre>"},{"location":"reference/codexctl/lib/docker/","title":"docker","text":""},{"location":"reference/codexctl/lib/docker/#codexctl.lib.docker","title":"<code>docker</code>","text":""},{"location":"reference/codexctl/lib/fs/","title":"fs","text":""},{"location":"reference/codexctl/lib/fs/#codexctl.lib.fs","title":"<code>fs</code>","text":""},{"location":"reference/codexctl/lib/git_gate/","title":"git_gate","text":""},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate","title":"<code>git_gate</code>","text":""},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate.GateStalenessInfo","title":"<code>GateStalenessInfo(branch, gate_head, upstream_head, is_stale, commits_behind, last_checked, error)</code>  <code>dataclass</code>","text":"<p>Result of comparing gate vs upstream.</p>"},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate.get_gate_last_commit","title":"<code>get_gate_last_commit(project_id)</code>","text":"<p>Get information about the last commit in the gate repository.</p> <p>Returns a dict with keys: commit_hash, commit_date, commit_message, commit_author, or None if the gate doesn't exist or is not accessible.</p> <p>This is a cheap operation that doesn't update the gate.</p> Source code in <code>src/codexctl/lib/git_gate.py</code> <pre><code>def get_gate_last_commit(project_id: str) -&gt; dict | None:\n    \"\"\"Get information about the last commit in the gate repository.\n\n    Returns a dict with keys: commit_hash, commit_date, commit_message, commit_author,\n    or None if the gate doesn't exist or is not accessible.\n\n    This is a cheap operation that doesn't update the gate.\n    \"\"\"\n    try:\n        project = load_project(project_id)\n        gate_dir = project.gate_path\n\n        if not gate_dir.exists() or not gate_dir.is_dir():\n            return None\n\n        # Build git environment that forces use of the project's SSH config (if present)\n        env = _git_env_with_ssh(project)\n\n        # Get the last commit info from the default branch\n        # We use git log with specific format to get structured data\n        cmd = [\n            \"git\",\n            \"-C\",\n            str(gate_dir),\n            \"log\",\n            \"-1\",\n            \"--pretty=format:%H|%ad|%s|%an\",\n            \"--date=iso\",\n        ]\n\n        result = subprocess.run(cmd, capture_output=True, text=True, env=env)\n        if result.returncode != 0:\n            return None\n\n        # Parse the output: hash|date|subject|author\n        parts = result.stdout.strip().split(\"|\", 3)\n        if len(parts) == 4:\n            return {\n                \"commit_hash\": parts[0],\n                \"commit_date\": parts[1],\n                \"commit_message\": parts[2],\n                \"commit_author\": parts[3],\n            }\n        return None\n\n    except Exception:\n        # If anything goes wrong, return None - this is a best-effort operation\n        return None\n</code></pre>"},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate.init_project_gate","title":"<code>init_project_gate(project_id, force=False)</code>","text":"<p>Create or update a host-side git mirror gate for a project.</p> <ul> <li>Uses the project's SSH configuration (from ssh-init) via GIT_SSH_COMMAND.</li> <li>If gate doesn't exist or --force is given, performs a fresh <code>git clone --mirror</code>.</li> <li>Otherwise, runs <code>git remote update --prune</code> to sync.</li> </ul> <p>Returns a dict with keys: path, upstream_url, created (bool).</p> Source code in <code>src/codexctl/lib/git_gate.py</code> <pre><code>def init_project_gate(project_id: str, force: bool = False) -&gt; dict:\n    \"\"\"Create or update a host-side git mirror gate for a project.\n\n    - Uses the project's SSH configuration (from ssh-init) via GIT_SSH_COMMAND.\n    - If gate doesn't exist or --force is given, performs a fresh `git clone --mirror`.\n    - Otherwise, runs `git remote update --prune` to sync.\n\n    Returns a dict with keys: path, upstream_url, created (bool).\n    \"\"\"\n    project = load_project(project_id)\n    if not project.upstream_url:\n        raise SystemExit(\"Project has no git.upstream_url configured\")\n\n    gate_dir = project.gate_path\n    gate_dir.parent.mkdir(parents=True, exist_ok=True)\n\n    # Determine if upstream requires SSH and ensure we only use the project's SSH dir\n    upstream = project.upstream_url\n    is_ssh_upstream = False\n    try:\n        is_ssh_upstream = upstream.startswith(\"git@\") or upstream.startswith(\"ssh://\")\n    except Exception:\n        is_ssh_upstream = False\n\n    # Resolve the project's ssh dir and config path (created by ssh-init)\n    ssh_dir = project.ssh_host_dir or (get_envs_base_dir() / f\"_ssh-config-{project.id}\")\n    ssh_cfg_path = Path(ssh_dir) / \"config\"\n\n    if is_ssh_upstream:\n        # For SSH upstreams, require the project-specific config; do NOT fall back to ~/.ssh\n        if not ssh_cfg_path.is_file():\n            raise SystemExit(\n                \"SSH upstream detected but project SSH config is missing.\\n\"\n                f\"Expected SSH config at: {ssh_cfg_path}\\n\"\n                f\"Run 'codexctl ssh-init {project.id}' first to generate keys and config.\"\n            )\n\n    # Build git environment that forces use of the project's SSH config (if present)\n    env = _git_env_with_ssh(project)\n\n    created = False\n    if force and gate_dir.exists():\n        # Remove to ensure clean mirror\n        try:\n            if gate_dir.is_dir():\n                shutil.rmtree(gate_dir)\n        except Exception:\n            # Best-effort cleanup; ignore delete failures.\n            pass\n\n    if not gate_dir.exists():\n        # Create a mirror clone\n        cmd = [\"git\", \"clone\", \"--mirror\", project.upstream_url, str(gate_dir)]\n        try:\n            subprocess.run(cmd, check=True, env=env)\n        except FileNotFoundError:\n            raise SystemExit(\"git not found on host; please install git\")\n        except subprocess.CalledProcessError as e:\n            raise SystemExit(f\"git clone --mirror failed: {e}\")\n        created = True\n    else:\n        # Update existing mirror\n        try:\n            subprocess.run(\n                [\"git\", \"-C\", str(gate_dir), \"remote\", \"update\", \"--prune\"], check=True, env=env\n            )\n        except subprocess.CalledProcessError as e:\n            raise SystemExit(f\"git remote update failed: {e}\")\n\n    return {\"path\": str(gate_dir), \"upstream_url\": project.upstream_url, \"created\": created}\n</code></pre>"},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate.get_upstream_head","title":"<code>get_upstream_head(project_id, branch=None)</code>","text":"<p>Query upstream HEAD ref using git ls-remote (cheap, no object download).</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project identifier</p> required <code>branch</code> <code>str</code> <p>Specific branch to check (default: project's default_branch)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>Dict with keys: commit_hash, ref_name, upstream_url</p> <code>dict | None</code> <p>or None if query fails</p> Source code in <code>src/codexctl/lib/git_gate.py</code> <pre><code>def get_upstream_head(project_id: str, branch: str = None) -&gt; dict | None:\n    \"\"\"Query upstream HEAD ref using git ls-remote (cheap, no object download).\n\n    Args:\n        project_id: Project identifier\n        branch: Specific branch to check (default: project's default_branch)\n\n    Returns:\n        Dict with keys: commit_hash, ref_name, upstream_url\n        or None if query fails\n    \"\"\"\n    try:\n        project = load_project(project_id)\n        if not project.upstream_url:\n            return None\n\n        branch = branch or project.default_branch\n        env = _git_env_with_ssh(project)\n\n        # git ls-remote only queries refs, doesn't download objects\n        cmd = [\"git\", \"ls-remote\", project.upstream_url, f\"refs/heads/{branch}\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, env=env, timeout=30)\n\n        if result.returncode != 0:\n            return None\n\n        # Parse output: \"&lt;commit_hash&gt;\\t&lt;ref_name&gt;\"\n        line = result.stdout.strip()\n        if not line:\n            return None\n\n        parts = line.split(\"\\t\")\n        if len(parts) &gt;= 2:\n            return {\n                \"commit_hash\": parts[0],\n                \"ref_name\": parts[1],\n                \"upstream_url\": project.upstream_url,\n            }\n        return None\n\n    except (subprocess.TimeoutExpired, Exception):\n        return None\n</code></pre>"},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate.get_gate_branch_head","title":"<code>get_gate_branch_head(project_id, branch=None)</code>","text":"<p>Get the commit hash for a specific branch in the gate.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project identifier</p> required <code>branch</code> <code>str</code> <p>Branch name (default: project's default_branch)</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Commit hash string or None if not found</p> Source code in <code>src/codexctl/lib/git_gate.py</code> <pre><code>def get_gate_branch_head(project_id: str, branch: str = None) -&gt; str | None:\n    \"\"\"Get the commit hash for a specific branch in the gate.\n\n    Args:\n        project_id: Project identifier\n        branch: Branch name (default: project's default_branch)\n\n    Returns:\n        Commit hash string or None if not found\n    \"\"\"\n    try:\n        project = load_project(project_id)\n        gate_dir = project.gate_path\n\n        if not gate_dir.exists():\n            return None\n\n        branch = branch or project.default_branch\n        env = _git_env_with_ssh(project)\n\n        # Query the ref in the bare mirror\n        cmd = [\"git\", \"-C\", str(gate_dir), \"rev-parse\", f\"refs/heads/{branch}\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, env=env)\n\n        if result.returncode == 0:\n            return result.stdout.strip()\n        return None\n\n    except Exception:\n        return None\n</code></pre>"},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate.compare_gate_vs_upstream","title":"<code>compare_gate_vs_upstream(project_id, branch=None)</code>","text":"<p>Compare gate HEAD vs upstream HEAD for a branch.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project identifier</p> required <code>branch</code> <code>str</code> <p>Branch to compare (default: project's default_branch)</p> <code>None</code> <p>Returns:</p> Type Description <code>GateStalenessInfo</code> <p>GateStalenessInfo with comparison results</p> Source code in <code>src/codexctl/lib/git_gate.py</code> <pre><code>def compare_gate_vs_upstream(project_id: str, branch: str = None) -&gt; GateStalenessInfo:\n    \"\"\"Compare gate HEAD vs upstream HEAD for a branch.\n\n    Args:\n        project_id: Project identifier\n        branch: Branch to compare (default: project's default_branch)\n\n    Returns:\n        GateStalenessInfo with comparison results\n    \"\"\"\n    project = load_project(project_id)\n    branch = branch or project.default_branch\n    now = datetime.now().isoformat()\n\n    # Get gate HEAD\n    gate_head = get_gate_branch_head(project_id, branch)\n    if gate_head is None:\n        return GateStalenessInfo(\n            branch=branch,\n            gate_head=None,\n            upstream_head=None,\n            is_stale=False,\n            commits_behind=None,\n            last_checked=now,\n            error=\"Gate not initialized\",\n        )\n\n    # Get upstream HEAD\n    upstream_info = get_upstream_head(project_id, branch)\n    if upstream_info is None:\n        return GateStalenessInfo(\n            branch=branch,\n            gate_head=gate_head,\n            upstream_head=None,\n            is_stale=False,\n            commits_behind=None,\n            last_checked=now,\n            error=\"Could not reach upstream\",\n        )\n\n    upstream_head = upstream_info[\"commit_hash\"]\n    is_stale = gate_head != upstream_head\n\n    # Try to count commits behind using git rev-list\n    commits_behind = None\n    if is_stale:\n        commits_behind = _count_commits_behind(project_id, gate_head, upstream_head)\n\n    return GateStalenessInfo(\n        branch=branch,\n        gate_head=gate_head,\n        upstream_head=upstream_head,\n        is_stale=is_stale,\n        commits_behind=commits_behind if is_stale else 0,\n        last_checked=now,\n        error=None,\n    )\n</code></pre>"},{"location":"reference/codexctl/lib/git_gate/#codexctl.lib.git_gate.sync_gate_branches","title":"<code>sync_gate_branches(project_id, branches=None)</code>","text":"<p>Sync specific branches in the gate from upstream.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project identifier</p> required <code>branches</code> <code>list[str]</code> <p>List of branches to sync (default: all via remote update)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dict with keys: success, updated_branches, errors</p> Source code in <code>src/codexctl/lib/git_gate.py</code> <pre><code>def sync_gate_branches(project_id: str, branches: list[str] = None) -&gt; dict:\n    \"\"\"Sync specific branches in the gate from upstream.\n\n    Args:\n        project_id: Project identifier\n        branches: List of branches to sync (default: all via remote update)\n\n    Returns:\n        Dict with keys: success, updated_branches, errors\n    \"\"\"\n    project = load_project(project_id)\n    gate_dir = project.gate_path\n\n    if not gate_dir.exists():\n        return {\"success\": False, \"updated_branches\": [], \"errors\": [\"Gate not initialized\"]}\n\n    env = _git_env_with_ssh(project)\n    errors = []\n    updated = []\n\n    try:\n        # Use git remote update for efficiency\n        cmd = [\"git\", \"-C\", str(gate_dir), \"remote\", \"update\", \"--prune\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, env=env, timeout=120)\n\n        if result.returncode != 0:\n            errors.append(f\"remote update failed: {result.stderr}\")\n        else:\n            # If specific branches requested, verify they were updated\n            updated = branches if branches else [\"all\"]\n\n    except subprocess.TimeoutExpired:\n        errors.append(\"Sync timed out\")\n    except Exception as e:\n        errors.append(str(e))\n\n    return {\"success\": len(errors) == 0, \"updated_branches\": updated, \"errors\": errors}\n</code></pre>"},{"location":"reference/codexctl/lib/images/","title":"images","text":""},{"location":"reference/codexctl/lib/images/#codexctl.lib.images","title":"<code>images</code>","text":""},{"location":"reference/codexctl/lib/paths/","title":"paths","text":""},{"location":"reference/codexctl/lib/paths/#codexctl.lib.paths","title":"<code>paths</code>","text":""},{"location":"reference/codexctl/lib/paths/#codexctl.lib.paths.config_root","title":"<code>config_root()</code>","text":"<p>Base directory for configuration (project.yml, projects/, etc.).</p> Priority <ol> <li>CODEXCTL_CONFIG_DIR</li> <li>if root   \u2192 /etc/codexctl    else      \u2192 ~/.config/codexctl</li> </ol> Source code in <code>src/codexctl/lib/paths.py</code> <pre><code>def config_root() -&gt; Path:\n    \"\"\"\n    Base directory for configuration (project.yml, projects/, etc.).\n\n    Priority:\n      1. CODEXCTL_CONFIG_DIR\n      2. if root   \u2192 /etc/codexctl\n         else      \u2192 ~/.config/codexctl\n    \"\"\"\n    env = os.getenv(\"CODEXCTL_CONFIG_DIR\")\n    if env:\n        return Path(env).expanduser()\n\n    if _is_root():\n        return Path(\"/etc\") / APP_NAME\n\n    if _user_config_dir is not None:\n        return Path(_user_config_dir(APP_NAME))\n    return Path.home() / \".config\" / APP_NAME\n</code></pre>"},{"location":"reference/codexctl/lib/paths/#codexctl.lib.paths.state_root","title":"<code>state_root()</code>","text":"<p>Writable state (tasks, pods, caches).</p> Priority <ol> <li>CODEXCTL_STATE_DIR</li> <li>if root   \u2192 /var/lib/codexctl    else      \u2192 ${XDG_DATA_HOME:-~/.local/share}/codexctl</li> </ol> Source code in <code>src/codexctl/lib/paths.py</code> <pre><code>def state_root() -&gt; Path:\n    \"\"\"\n    Writable state (tasks, pods, caches).\n\n    Priority:\n      1. CODEXCTL_STATE_DIR\n      2. if root   \u2192 /var/lib/codexctl\n         else      \u2192 ${XDG_DATA_HOME:-~/.local/share}/codexctl\n    \"\"\"\n    env = os.getenv(\"CODEXCTL_STATE_DIR\")\n    if env:\n        return Path(env).expanduser()\n\n    if _is_root():\n        return Path(\"/var/lib\") / APP_NAME\n\n    if _user_data_dir is not None:\n        return Path(_user_data_dir(APP_NAME))\n\n    # Fallback without platformdirs: honor XDG_DATA_HOME if set\n    xdg = os.getenv(\"XDG_DATA_HOME\")\n    if xdg:\n        return Path(xdg) / APP_NAME\n    return Path.home() / \".local\" / \"share\" / APP_NAME\n</code></pre>"},{"location":"reference/codexctl/lib/paths/#codexctl.lib.paths.runtime_root","title":"<code>runtime_root()</code>","text":"<p>Transient runtime bits.</p> Priority <ol> <li>CODEXCTL_RUNTIME_DIR</li> <li>if root   \u2192 /run/codexctl    else      \u2192 ~/.cache/codexctl</li> </ol> Source code in <code>src/codexctl/lib/paths.py</code> <pre><code>def runtime_root() -&gt; Path:\n    \"\"\"\n    Transient runtime bits.\n\n    Priority:\n      1. CODEXCTL_RUNTIME_DIR\n      2. if root   \u2192 /run/codexctl\n         else      \u2192 ~/.cache/codexctl\n    \"\"\"\n    env = os.getenv(\"CODEXCTL_RUNTIME_DIR\")\n    if env:\n        return Path(env).expanduser()\n\n    if _is_root():\n        return Path(\"/run\") / APP_NAME\n\n    return Path.home() / \".cache\" / APP_NAME\n</code></pre>"},{"location":"reference/codexctl/lib/podman/","title":"podman","text":""},{"location":"reference/codexctl/lib/podman/#codexctl.lib.podman","title":"<code>podman</code>","text":""},{"location":"reference/codexctl/lib/projects/","title":"projects","text":""},{"location":"reference/codexctl/lib/projects/#codexctl.lib.projects","title":"<code>projects</code>","text":""},{"location":"reference/codexctl/lib/projects/#codexctl.lib.projects.list_projects","title":"<code>list_projects()</code>","text":"<p>Discover all projects (user + system) and return them as Project objects. User projects override system ones with the same id.</p> Source code in <code>src/codexctl/lib/projects.py</code> <pre><code>def list_projects() -&gt; list[Project]:\n    \"\"\"\n    Discover all projects (user + system) and return them as Project objects.\n    User projects override system ones with the same id.\n    \"\"\"\n    ids: set[str] = set()\n\n    # Collect IDs from user and system project dirs\n    for root in (user_projects_root(), config_root()):\n        if not root.is_dir():\n            continue\n        for d in root.iterdir():\n            if not d.is_dir():\n                continue\n            if (d / \"project.yml\").is_file():\n                ids.add(d.name)\n\n    projects: list[Project] = []\n    for pid in sorted(ids):\n        # load_project will automatically prefer user over system config\n        try:\n            projects.append(load_project(pid))\n        except SystemExit:\n            # if a project is broken, skip it rather than crashing the listing\n            continue\n    return projects\n</code></pre>"},{"location":"reference/codexctl/lib/projects/#codexctl.lib.projects.get_project_state","title":"<code>get_project_state(project_id)</code>","text":"<p>Return a summary of per-project infrastructure state.</p> <p>The resulting dict contains boolean flags that can be used by UIs (including the TUI) to give a quick overview of the project:</p> <ul> <li><code>dockerfiles</code> - True if all required Dockerfiles (L0, L1.cli, L1.ui, L2) exist   under the build root for this project.</li> <li><code>images</code> - True if podman reports that images <code>&lt;id&gt;:l2-cli</code>   and <code>&lt;id&gt;:l2-ui</code> exist.</li> <li><code>ssh</code> - True if the project SSH directory exists and contains   a <code>config</code> file.</li> <li><code>gate</code> - True if the project's git gate directory exists.</li> <li><code>gate_last_commit</code> - Dict with commit info if gate exists, None otherwise.</li> </ul> Source code in <code>src/codexctl/lib/projects.py</code> <pre><code>def get_project_state(project_id: str) -&gt; dict:\n    \"\"\"Return a summary of per-project infrastructure state.\n\n    The resulting dict contains boolean flags that can be used by UIs\n    (including the TUI) to give a quick overview of the project:\n\n    - ``dockerfiles`` - True if all required Dockerfiles (L0, L1.cli, L1.ui, L2) exist\n      under the build root for this project.\n    - ``images`` - True if podman reports that images ``&lt;id&gt;:l2-cli``\n      and ``&lt;id&gt;:l2-ui`` exist.\n    - ``ssh`` - True if the project SSH directory exists and contains\n      a ``config`` file.\n    - ``gate`` - True if the project's git gate directory exists.\n    - ``gate_last_commit`` - Dict with commit info if gate exists, None otherwise.\n    \"\"\"\n\n    project = load_project(project_id)\n\n    # Dockerfiles: look in the same location generate_dockerfiles writes to.\n    stage_dir = build_root() / project.id\n    dockerfiles = [\n        stage_dir / \"L0.Dockerfile\",\n        stage_dir / \"L1.cli.Dockerfile\",\n        stage_dir / \"L1.ui.Dockerfile\",\n        stage_dir / \"L2.Dockerfile\",\n    ]\n    has_dockerfiles = all(p.is_file() for p in dockerfiles)\n\n    # Images: rely on podman image tags created by build_images().\n    has_images = False\n    try:\n        required_tags = [\n            project_cli_image(project.id),\n            project_ui_image(project.id),\n        ]\n        ok = True\n        for tag in required_tags:\n            # ``podman image exists`` exits with 0 when the image is present.\n            result = subprocess.run(\n                [\"podman\", \"image\", \"exists\", tag],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n            )\n            if result.returncode != 0:\n                ok = False\n                break\n        has_images = ok\n    except (FileNotFoundError, OSError):  # podman missing or not usable\n        has_images = False\n\n    # SSH: same resolution logic as init_project_ssh(). Consider SSH\n    # \"ready\" when the directory and its config file exist.\n    ssh_dir = project.ssh_host_dir or (get_envs_base_dir() / f\"_ssh-config-{project.id}\")\n    ssh_dir = Path(ssh_dir).expanduser().resolve()\n    has_ssh = ssh_dir.is_dir() and (ssh_dir / \"config\").is_file()\n\n    # Gate: a mirror bare repo initialized by init_project_gate(). We\n    # treat existence of the directory as \"gate present\".\n    gate_dir = project.gate_path\n    has_gate = gate_dir.is_dir()\n\n    # Get gate commit info if gate exists\n    gate_last_commit = None\n    if has_gate:\n        # Import here to avoid circular import\n        from .git_gate import get_gate_last_commit\n\n        gate_last_commit = get_gate_last_commit(project_id)\n\n    return {\n        \"dockerfiles\": has_dockerfiles,\n        \"images\": has_images,\n        \"ssh\": has_ssh,\n        \"gate\": has_gate,\n        \"gate_last_commit\": gate_last_commit,\n    }\n</code></pre>"},{"location":"reference/codexctl/lib/ssh/","title":"ssh","text":""},{"location":"reference/codexctl/lib/ssh/#codexctl.lib.ssh","title":"<code>ssh</code>","text":""},{"location":"reference/codexctl/lib/ssh/#codexctl.lib.ssh.init_project_ssh","title":"<code>init_project_ssh(project_id, key_type='ed25519', key_name=None, force=False)</code>","text":"<p>Initialize the shared SSH directory for a project and generate a keypair.</p> <p>This prepares the host directory that containers mount read-write at /home/dev/.ssh and creates an SSH keypair plus a minimal config file if missing.</p> Location resolution <ul> <li>If project.yml defines ssh.host_dir, use that path.</li> <li>Otherwise: /_ssh-config- Key name <ul> <li>Defaults to id__ (e.g. id_ed25519_proj) <p>Returns a dict with keys: dir, private_key, public_key, config_path, key_name.</p> Source code in <code>src/codexctl/lib/ssh.py</code> <pre><code>def init_project_ssh(\n    project_id: str,\n    key_type: str = \"ed25519\",\n    key_name: str | None = None,\n    force: bool = False,\n) -&gt; dict:\n    \"\"\"Initialize the shared SSH directory for a project and generate a keypair.\n\n    This prepares the host directory that containers mount read-write at /home/dev/.ssh\n    and creates an SSH keypair plus a minimal config file if missing.\n\n    Location resolution:\n      - If project.yml defines ssh.host_dir, use that path.\n      - Otherwise: &lt;envs_base&gt;/_ssh-config-&lt;project_id&gt;\n\n    Key name:\n      - Defaults to id_&lt;type&gt;_&lt;project_id&gt; (e.g. id_ed25519_proj)\n\n    Returns a dict with keys: dir, private_key, public_key, config_path, key_name.\n    \"\"\"\n    if key_type not in (\"ed25519\", \"rsa\"):\n        raise SystemExit(\"Unsupported --key-type. Use 'ed25519' or 'rsa'.\")\n\n    project = load_project(project_id)\n\n    target_dir = project.ssh_host_dir or (get_envs_base_dir() / f\"_ssh-config-{project.id}\")\n    target_dir = Path(target_dir).expanduser().resolve()\n    _ensure_dir_writable(target_dir, \"SSH host dir\")\n\n    # If caller did not supply an explicit key_name, derive it from project\n    # configuration using the shared helper so ssh-init, containers and git\n    # helpers all agree on the filename.\n    if not key_name:\n        key_name = _effective_ssh_key_name(project, key_type=key_type)\n\n    priv_path = target_dir / key_name\n    pub_path = target_dir / f\"{key_name}.pub\"\n    cfg_path = target_dir / \"config\"\n\n    # Generate keypair if needed (or forced)\n    need_generate = force or (not priv_path.exists() or not pub_path.exists())\n    if need_generate:\n        # Remove existing when forced to avoid ssh-keygen prompt\n        if force:\n            try:\n                if priv_path.exists():\n                    priv_path.unlink()\n                if pub_path.exists():\n                    pub_path.unlink()\n            except Exception:\n                # Best-effort cleanup before regenerating keys.\n                pass\n\n        cmd = [\n            \"ssh-keygen\",\n            \"-t\",\n            key_type,\n            \"-f\",\n            str(priv_path),\n            \"-N\",\n            \"\",\n            \"-C\",\n            f\"codexctl {project.id} {getpass.getuser()}@{socket.gethostname()}\",\n        ]\n        try:\n            subprocess.run(cmd, check=True)\n        except FileNotFoundError:\n            raise SystemExit(\"ssh-keygen not found. Please install OpenSSH client tools.\")\n        except subprocess.CalledProcessError as e:\n            raise SystemExit(f\"ssh-keygen failed: {e}\")\n\n        # Best-effort permissions\n        try:\n            os.chmod(priv_path, 0o600)\n            os.chmod(pub_path, 0o644)\n        except Exception:\n            # Permission adjustments are best-effort.\n            pass\n\n    # Ensure config exists and references the key. Render from user or packaged template.\n    if (force and cfg_path.exists()) or (not cfg_path.exists()):\n        # If force, overwrite; otherwise create if missing\n        # Prefer project-provided template; else use packaged default.\n        user_template_path: Path | None = None\n        if getattr(project, \"ssh_config_template\", None):\n            tp: Path = project.ssh_config_template  # type: ignore[assignment]\n            if tp.is_file():\n                user_template_path = tp\n        # Packaged template (importlib.resources Traversable)\n        packaged_template = None\n        try:\n            packaged_template = (\n                resources.files(\"codexctl\") / \"resources\" / \"templates\" / \"ssh_config.template\"\n            )\n        except Exception:\n            packaged_template = None\n\n        config_text: str | None = None\n        variables = {\n            \"KEY_NAME\": key_name,\n        }\n        # Prefer user template if provided\n        if user_template_path is not None:\n            try:\n                config_text = render_template(user_template_path, variables)\n            except Exception:\n                config_text = None\n        # Otherwise use packaged template (works from wheels/zip)\n        if not config_text and packaged_template is not None:\n            try:\n                raw = packaged_template.read_text()\n                for k, v in variables.items():\n                    raw = raw.replace(f\"{{{{{k}}}}}\", str(v))\n                config_text = raw\n            except Exception:\n                config_text = None\n\n        if not config_text:\n            raise SystemExit(\n                \"Failed to render SSH config: no valid template. \"\n                \"Ensure a project ssh.config_template is set or the packaged template exists.\"\n            )\n\n        try:\n            cfg_path.write_text(config_text)\n        except Exception as e:\n            raise SystemExit(f\"Failed to write SSH config at {cfg_path}: {e}\")\n\n    # Best-effort permissions for container dev user access.\n    try:\n        os.chmod(target_dir, 0o700)\n        if priv_path.exists():\n            os.chmod(priv_path, 0o600)\n        if pub_path.exists():\n            os.chmod(pub_path, 0o644)\n        if cfg_path.exists():\n            os.chmod(cfg_path, 0o644)\n    except Exception:\n        # Permission adjustments are best-effort.\n        pass\n\n    print(\"SSH directory initialized:\")\n    print(f\"  dir:         {target_dir}\")\n    print(f\"  private key: {priv_path}\")\n    print(f\"  public key:  {pub_path}\")\n    print(f\"  config:      {cfg_path}\")\n\n    # Also echo the actual public key contents for easy copy-paste.\n    # Best-effort: if reading fails, continue without raising.\n    try:\n        if pub_path.exists():\n            pub_key_text = pub_path.read_text(encoding=\"utf-8\", errors=\"ignore\").strip()\n            if pub_key_text:\n                print(\"Public key:\")\n                print(f\"  {pub_key_text}\")\n    except Exception:\n        # Reading the public key is best-effort.\n        pass\n    # When ssh.key_name is omitted in project.yml, we still derive a stable\n    # default filename (id_&lt;algo&gt;_&lt;project_id&gt;) via _effective_ssh_key_name.\n    # Containers receive only this bare filename via SSH_KEY_NAME and mount\n    # the host ssh_host_dir at /home/dev/.ssh, so path handling remains\n    # host-side while the filename is consistent everywhere.\n    if not project.ssh_key_name:\n        print(\n            \"Note: project.yml does not define ssh.key_name; using a derived default key filename.\"\n        )\n        print(\n            f\"      To pin the SSH key filename explicitly, add to {project.root / 'project.yml'}:\\n        ssh:\\n          key_name: {key_name}\"\n        )\n\n    return {\n        \"dir\": str(target_dir),\n        \"private_key\": str(priv_path),\n        \"public_key\": str(pub_path),\n        \"config_path\": str(cfg_path),\n        \"key_name\": key_name,\n    }\n</code></pre>"},{"location":"reference/codexctl/lib/tasks/","title":"tasks","text":""},{"location":"reference/codexctl/lib/tasks/#codexctl.lib.tasks","title":"<code>tasks</code>","text":""},{"location":"reference/codexctl/lib/tasks/#codexctl.lib.tasks.get_workspace_git_diff","title":"<code>get_workspace_git_diff(project_id, task_id, against='HEAD')</code>","text":"<p>Get git diff from a task's workspace.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project ID</p> required <code>task_id</code> <code>str</code> <p>The task ID</p> required <code>against</code> <code>str</code> <p>What to diff against (\"HEAD\" or \"PREV\")</p> <code>'HEAD'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The git diff output as a string, or None if failed</p> Source code in <code>src/codexctl/lib/tasks.py</code> <pre><code>def get_workspace_git_diff(project_id: str, task_id: str, against: str = \"HEAD\") -&gt; str | None:\n    \"\"\"Get git diff from a task's workspace.\n\n    Args:\n        project_id: The project ID\n        task_id: The task ID\n        against: What to diff against (\"HEAD\" or \"PREV\")\n\n    Returns:\n        The git diff output as a string, or None if failed\n    \"\"\"\n    try:\n        project = load_project(project_id)\n        tasks_root = project.tasks_root\n        workspace_dir = tasks_root / task_id / \"workspace\"\n\n        if not workspace_dir.exists() or not workspace_dir.is_dir():\n            return None\n\n        # Check if this is a git repository\n        git_dir = workspace_dir / \".git\"\n        if not git_dir.exists():\n            return None\n\n        # Determine what to diff against\n        if against == \"PREV\":\n            # Diff against previous commit\n            cmd = [\"git\", \"-C\", str(workspace_dir), \"diff\", \"HEAD~1\", \"HEAD\"]\n        else:\n            # Default: diff against HEAD (uncommitted changes)\n            cmd = [\"git\", \"-C\", str(workspace_dir), \"diff\", \"HEAD\"]\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        if result.returncode != 0:\n            # Non-zero return code indicates an error; treat as failure\n            return None\n\n        # Successful run; stdout may be empty if there is no diff\n        return result.stdout\n\n    except Exception:\n        # If anything goes wrong, return None - this is a best-effort operation\n        return None\n</code></pre>"},{"location":"reference/codexctl/lib/tasks/#codexctl.lib.tasks.copy_to_clipboard","title":"<code>copy_to_clipboard(text)</code>","text":"<p>Copy text to system clipboard.</p> <p>Tries multiple clipboard utilities in order of preference: 1. wl-copy (Wayland) 2. xclip (X11) 3. pbcopy (macOS)</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to copy to clipboard</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Source code in <code>src/codexctl/lib/tasks.py</code> <pre><code>def copy_to_clipboard(text: str) -&gt; bool:\n    \"\"\"Copy text to system clipboard.\n\n    Tries multiple clipboard utilities in order of preference:\n    1. wl-copy (Wayland)\n    2. xclip (X11)\n    3. pbcopy (macOS)\n\n    Args:\n        text: Text to copy to clipboard\n\n    Returns:\n        True if successful, False otherwise\n    \"\"\"\n    if not text:\n        return False\n\n    # Try wl-copy first (Wayland)\n    try:\n        subprocess.run([\"wl-copy\", \"--type\", \"text/plain\"], input=text, check=True, text=True)\n        return True\n    except (FileNotFoundError, subprocess.CalledProcessError):\n        pass\n\n    # Try xclip (X11)\n    try:\n        subprocess.run([\"xclip\", \"-selection\", \"clipboard\"], input=text, check=True, text=True)\n        return True\n    except (FileNotFoundError, subprocess.CalledProcessError):\n        pass\n\n    # Try pbcopy (macOS)\n    try:\n        subprocess.run([\"pbcopy\"], input=text, check=True, text=True)\n        return True\n    except (FileNotFoundError, subprocess.CalledProcessError):\n        pass\n\n    return False\n</code></pre>"},{"location":"reference/codexctl/lib/tasks/#codexctl.lib.tasks.task_new","title":"<code>task_new(project_id)</code>","text":"<p>Create a new task with a fresh workspace for a project.</p>"},{"location":"reference/codexctl/lib/tasks/#codexctl.lib.tasks.task_new--workspace-initialization-protocol","title":"Workspace Initialization Protocol:","text":"<p>Each task gets its own workspace directory that persists across container runs. When a container starts, the init script (init-ssh-and-repo.sh) needs to know whether this is:</p> <ol> <li>A NEW task that should be reset to the latest remote HEAD</li> <li>A RESTARTED task where local changes should be preserved</li> </ol> <p>We use a marker file (.new-task-marker) to signal intent:</p> <ul> <li>task_new() creates the marker in the workspace directory</li> <li>init-ssh-and-repo.sh checks for the marker:</li> <li>If marker exists: reset to origin/HEAD, then delete marker</li> <li>If no marker: fetch only, preserve local state</li> <li>Subsequent container runs on the same task won't see the marker,   so local work is preserved</li> </ul> <p>This handles edge cases like: - Stale workspace from incompletely deleted previous task with same ID - Ensuring new tasks always start with latest code</p> Source code in <code>src/codexctl/lib/tasks.py</code> <pre><code>def task_new(project_id: str) -&gt; None:\n    \"\"\"Create a new task with a fresh workspace for a project.\n\n    Workspace Initialization Protocol:\n    ----------------------------------\n    Each task gets its own workspace directory that persists across container\n    runs. When a container starts, the init script (init-ssh-and-repo.sh) needs\n    to know whether this is:\n\n    1. A NEW task that should be reset to the latest remote HEAD\n    2. A RESTARTED task where local changes should be preserved\n\n    We use a marker file (.new-task-marker) to signal intent:\n\n    - task_new() creates the marker in the workspace directory\n    - init-ssh-and-repo.sh checks for the marker:\n      - If marker exists: reset to origin/HEAD, then delete marker\n      - If no marker: fetch only, preserve local state\n    - Subsequent container runs on the same task won't see the marker,\n      so local work is preserved\n\n    This handles edge cases like:\n    - Stale workspace from incompletely deleted previous task with same ID\n    - Ensuring new tasks always start with latest code\n    \"\"\"\n    project = load_project(project_id)\n    tasks_root = project.tasks_root\n    _ensure_dir(tasks_root)\n    meta_dir = _tasks_meta_dir(project.id)\n    _ensure_dir(meta_dir)\n\n    # Simple ID: numeric increment\n    existing = sorted([p.stem for p in meta_dir.glob(\"*.yml\") if p.stem.isdigit()], key=int)\n    next_id = str(int(existing[-1]) + 1 if existing else 1)\n\n    ws = tasks_root / next_id\n    _ensure_dir(ws)\n\n    # Create the workspace subdirectory and place a marker file to signal\n    # that this is a fresh task. The init script will reset to latest HEAD\n    # when it sees this marker, then remove it. See docstring above.\n    workspace_dir = ws / \"workspace\"\n    _ensure_dir(workspace_dir)\n    marker_path = workspace_dir / \".new-task-marker\"\n    marker_path.write_text(\n        \"# This marker signals that the workspace should be reset to the latest remote HEAD.\\n\"\n        \"# It is created by 'codexctl task new' and removed by init-ssh-and-repo.sh after reset.\\n\"\n        \"# If you see this file in an initialized workspace, something went wrong.\\n\",\n        encoding=\"utf-8\",\n    )\n\n    meta = {\n        \"task_id\": next_id,\n        \"status\": \"created\",\n        \"mode\": None,\n        \"workspace\": str(ws),\n        \"ui_port\": None,\n    }\n    (meta_dir / f\"{next_id}.yml\").write_text(yaml.safe_dump(meta))\n    print(f\"Created task {next_id} in {ws}\")\n</code></pre>"},{"location":"reference/codexctl/lib/tasks/#codexctl.lib.tasks.task_delete","title":"<code>task_delete(project_id, task_id)</code>","text":"<p>Delete a task's workspace, metadata, and any associated containers.</p> <p>This mirrors the behavior used by the TUI when deleting a task, but is exposed here so both CLI and TUI share the same logic. Containers are stopped best-effort via podman using the naming scheme \"--\". Source code in <code>src/codexctl/lib/tasks.py</code> <pre><code>def task_delete(project_id: str, task_id: str) -&gt; None:\n    \"\"\"Delete a task's workspace, metadata, and any associated containers.\n\n    This mirrors the behavior used by the TUI when deleting a task, but is\n    exposed here so both CLI and TUI share the same logic. Containers are\n    stopped best-effort via podman using the naming scheme\n    \"&lt;project.id&gt;-&lt;mode&gt;-&lt;task_id&gt;\".\n    \"\"\"\n\n    _log_debug(f\"task_delete: start project_id={project_id} task_id={task_id}\")\n\n    project = load_project(project_id)\n    _log_debug(\"task_delete: loaded project\")\n\n    # Workspace lives under the project's tasks_root using the numeric ID.\n    workspace = project.tasks_root / str(task_id)\n\n    # Metadata lives in the per-project tasks state dir.\n    meta_dir = _tasks_meta_dir(project.id)\n    meta_path = meta_dir / f\"{task_id}.yml\"\n    _log_debug(f\"task_delete: workspace={workspace} meta_path={meta_path}\")\n\n    # Stop any matching containers first to avoid name conflicts if a new\n    # task is later created with the same ID.\n    _log_debug(\"task_delete: calling _stop_task_containers\")\n    _stop_task_containers(project, str(task_id))\n    _log_debug(\"task_delete: _stop_task_containers returned\")\n\n    if workspace.is_dir():\n        _log_debug(\"task_delete: removing workspace directory\")\n        shutil.rmtree(workspace)\n        _log_debug(\"task_delete: workspace directory removed\")\n\n    if meta_path.is_file():\n        _log_debug(\"task_delete: removing metadata file\")\n        meta_path.unlink()\n        _log_debug(\"task_delete: metadata file removed\")\n\n    _log_debug(\"task_delete: finished\")\n</code></pre>"},{"location":"reference/codexctl/lib/template_utils/","title":"template_utils","text":""},{"location":"reference/codexctl/lib/template_utils/#codexctl.lib.template_utils","title":"<code>template_utils</code>","text":""},{"location":"reference/codexctl/tui/","title":"tui","text":""},{"location":"reference/codexctl/tui/#codexctl.tui","title":"<code>tui</code>","text":"<p>codexctl TUI package.</p>"},{"location":"reference/codexctl/tui/app/","title":"app","text":""},{"location":"reference/codexctl/tui/app/#codexctl.tui.app","title":"<code>app</code>","text":""},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI","title":"<code>CodexTUI()</code>","text":"<p>               Bases: <code>App</code></p> <p>Minimal TUI frontend for codexctl core modules.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n    self.current_project_id: str | None = None\n    self.current_task: TaskMeta | None = None\n    # Set on mount; used to display status / notifications.\n    self._status_bar: StatusBar | None = None\n    # Upstream polling state\n    self._staleness_info: GateStalenessInfo | None = None\n    self._polling_timer = None\n    self._polling_project_id: str | None = None  # Project ID the timer was started for\n    self._last_notified_stale: bool = False  # Track if we already notified about staleness\n    self._auto_sync_cooldown: dict[str, float] = {}  # Per-project cooldown timestamps\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.notify","title":"<code>notify(message, *args, **kwargs)</code>","text":"<p>Display a notification/status message.</p> <p>We override Textual's App.notify so that notifications are mirrored into our custom bottom status bar while still delegating to the framework's native notification system when present.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>def notify(self, message: str, *args, **kwargs) -&gt; None:  # type: ignore[override]\n    \"\"\"Display a notification/status message.\n\n    We override Textual's App.notify so that notifications are\n    mirrored into our custom bottom status bar while still delegating\n    to the framework's native notification system when present.\n    \"\"\"\n\n    self._set_status(message)\n\n    # Best-effort delegation to the base implementation (for pop-up\n    # notifications etc.). On older/newer Textual versions notify()\n    # might not exist or have a different signature, so we guard it.\n    try:\n        super().notify(message, *args, **kwargs)  # type: ignore[misc,attr-defined]\n    except Exception:\n        pass\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.action_sync_gate","title":"<code>action_sync_gate()</code>  <code>async</code>","text":"<p>Manually sync gate from upstream.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>async def action_sync_gate(self) -&gt; None:\n    \"\"\"Manually sync gate from upstream.\"\"\"\n    if not self.current_project_id:\n        self.notify(\"No project selected.\")\n        return\n\n    try:\n        project = load_project(self.current_project_id)\n        if project.security_class != \"gatekeeping\":\n            self.notify(\"Sync only available for gatekeeping projects.\")\n            return\n\n        self.notify(\"Syncing gate from upstream...\")\n\n        # Run sync in background worker\n        self.run_worker(\n            self._sync_worker(self.current_project_id, None, is_auto=False),\n            name=\"manual_sync\",\n            exclusive=True,\n        )\n\n    except Exception as e:\n        self.notify(f\"Sync error: {e}\")\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.handle_project_selected","title":"<code>handle_project_selected(message)</code>  <code>async</code>","text":"<p>Called when user activates a project in the list.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>@on(ProjectList.ProjectSelected)\nasync def handle_project_selected(self, message: ProjectList.ProjectSelected) -&gt; None:\n    \"\"\"Called when user activates a project in the list.\"\"\"\n    self.current_project_id = message.project_id\n    await self.refresh_tasks()\n    # Start polling for the newly selected project\n    self._start_upstream_polling()\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.handle_task_selected","title":"<code>handle_task_selected(message)</code>  <code>async</code>","text":"<p>Called when user activates a task in the list.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>@on(TaskList.TaskSelected)\nasync def handle_task_selected(self, message: TaskList.TaskSelected) -&gt; None:\n    \"\"\"Called when user activates a task in the list.\"\"\"\n    self.current_project_id = message.project_id\n    self.current_task = message.task\n    details = self.query_one(\"#task-details\", TaskDetails)\n    details.set_task(self.current_task)\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.handle_copy_diff_requested","title":"<code>handle_copy_diff_requested(message)</code>  <code>async</code>","text":"<p>Called when user requests to copy git diff to clipboard.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>@on(TaskDetails.CopyDiffRequested)\nasync def handle_copy_diff_requested(self, message: TaskDetails.CopyDiffRequested) -&gt; None:\n    \"\"\"Called when user requests to copy git diff to clipboard.\"\"\"\n    if not self.current_project_id or not self.current_task:\n        self.notify(\"No task selected.\")\n        return\n\n    task_id = self.current_task.task_id\n    diff = get_workspace_git_diff(self.current_project_id, task_id, message.diff_type)\n\n    if diff is None:\n        self.notify(\"Failed to get git diff. Is this a git repository?\")\n        return\n\n    if diff == \"\":\n        self.notify(\"No changes to copy (working tree clean).\")\n        return\n\n    # Try to copy to clipboard\n    success = copy_to_clipboard(diff)\n    if success:\n        self.notify(f\"Git diff copied to clipboard ({len(diff)} characters)\")\n    else:\n        self.notify(\"Failed to copy to clipboard. Clipboard utility not found.\")\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.action_quit","title":"<code>action_quit()</code>  <code>async</code>","text":"<p>Exit the TUI cleanly.</p> <p>Older versions of this file attempted to call <code>self.shutdown()</code>, but <code>App</code> in modern Textual does not expose such a method. The supported way to terminate the application programmatically is to call <code>self.exit()</code>. Using <code>exit()</code> here avoids an <code>AttributeError</code> on quit while still delegating to Textual's normal shutdown/cleanup logic.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>async def action_quit(self) -&gt; None:\n    \"\"\"Exit the TUI cleanly.\n\n    Older versions of this file attempted to call ``self.shutdown()``,\n    but ``App`` in modern Textual does not expose such a method. The\n    supported way to terminate the application programmatically is to\n    call ``self.exit()``. Using ``exit()`` here avoids an\n    ``AttributeError`` on quit while still delegating to Textual's\n    normal shutdown/cleanup logic.\n    \"\"\"\n    # Stop upstream polling before exit\n    self._stop_upstream_polling()\n\n    # Textual's ``App`` provides ``exit()`` rather than ``shutdown()``;\n    # calling the latter would raise ``AttributeError``.\n    self.exit()\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.action_init_ssh","title":"<code>action_init_ssh()</code>  <code>async</code>","text":"<p>Initialize the per-project SSH directory and keypair.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>async def action_init_ssh(self) -&gt; None:\n    \"\"\"Initialize the per-project SSH directory and keypair.\"\"\"\n    if not self.current_project_id:\n        self.notify(\"No project selected.\")\n        return\n\n    with self.suspend():\n        try:\n            init_project_ssh(self.current_project_id)\n        except SystemExit as e:\n            print(f\"Error: {e}\")\n        input(\"\\n[Press Enter to return to CodexTUI] \")\n\n    self.notify(f\"Initialized SSH dir for {self.current_project_id}\")\n    self._refresh_project_state()\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.action_init_gate","title":"<code>action_init_gate()</code>  <code>async</code>","text":"<p>Initialize or update the git gate mirror for the project.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>async def action_init_gate(self) -&gt; None:\n    \"\"\"Initialize or update the git gate mirror for the project.\"\"\"\n    if not self.current_project_id:\n        self.notify(\"No project selected.\")\n        return\n\n    with self.suspend():\n        try:\n            res = init_project_gate(self.current_project_id)\n            print(\n                f\"Gate ready at {res['path']} \"\n                f\"(upstream: {res['upstream_url']}; created: {res['created']})\"\n            )\n        except SystemExit as e:\n            print(f\"Error: {e}\")\n        input(\"\\n[Press Enter to return to CodexTUI] \")\n\n    self.notify(f\"Git gate initialized for {self.current_project_id}\")\n    self._refresh_project_state()\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.action_copy_diff_head","title":"<code>action_copy_diff_head()</code>  <code>async</code>","text":"<p>Copy git diff vs HEAD to clipboard.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>async def action_copy_diff_head(self) -&gt; None:\n    \"\"\"Copy git diff vs HEAD to clipboard.\"\"\"\n    await self._copy_diff_to_clipboard(\"HEAD\", \"HEAD\")\n</code></pre>"},{"location":"reference/codexctl/tui/app/#codexctl.tui.app.CodexTUI.action_copy_diff_prev","title":"<code>action_copy_diff_prev()</code>  <code>async</code>","text":"<p>Copy git diff vs previous commit to clipboard.</p> Source code in <code>src/codexctl/tui/app.py</code> <pre><code>async def action_copy_diff_prev(self) -&gt; None:\n    \"\"\"Copy git diff vs previous commit to clipboard.\"\"\"\n    await self._copy_diff_to_clipboard(\"PREV\", \"PREV\")\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/","title":"widgets","text":""},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets","title":"<code>widgets</code>","text":""},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.ProjectList","title":"<code>ProjectList(**kwargs)</code>","text":"<p>               Bases: <code>ListView</code></p> <p>Left-hand project list widget.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.projects: list[CodexProject] = []\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.ProjectList.set_projects","title":"<code>set_projects(projects)</code>","text":"<p>Populate the list with projects.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def set_projects(self, projects: list[CodexProject]) -&gt; None:\n    \"\"\"Populate the list with projects.\"\"\"\n    self.projects = projects\n    self.clear()\n    for proj in projects:\n        label = f\"{proj.id} [{proj.security_class}]\"\n        # Disable Rich markup to avoid surprises\n        self.append(ListItem(Static(label, markup=False)))\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.ProjectList.select_project","title":"<code>select_project(project_id)</code>","text":"<p>Select a project by id.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def select_project(self, project_id: str) -&gt; None:\n    \"\"\"Select a project by id.\"\"\"\n    for idx, proj in enumerate(self.projects):\n        if proj.id == project_id:\n            self.index = idx\n            break\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.ProjectList.on_list_view_selected","title":"<code>on_list_view_selected(event)</code>","text":"<p>When user selects a row, send a semantic ProjectSelected message.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def on_list_view_selected(self, event: ListView.Selected) -&gt; None:  # type: ignore[override]\n    \"\"\"When user selects a row, send a semantic ProjectSelected message.\"\"\"\n    idx = self.index\n    if 0 &lt;= idx &lt; len(self.projects):\n        proj_id = self.projects[idx].id\n        self.post_message(self.ProjectSelected(proj_id))\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.ProjectActions","title":"<code>ProjectActions</code>","text":"<p>               Bases: <code>Static</code></p> <p>Single-row action bar for project + task actions.</p>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.TaskList","title":"<code>TaskList(**kwargs)</code>","text":"<p>               Bases: <code>ListView</code></p> <p>Middle pane: per-project tasks.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.project_id: str | None = None\n    self.tasks: list[TaskMeta] = []\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.TaskList.set_tasks","title":"<code>set_tasks(project_id, tasks_meta)</code>","text":"<p>Populate the list from raw metadata dicts.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def set_tasks(self, project_id: str, tasks_meta: list[dict[str, Any]]) -&gt; None:\n    \"\"\"Populate the list from raw metadata dicts.\"\"\"\n    self.project_id = project_id\n    self.tasks = []\n    self.clear()\n\n    for meta in tasks_meta:\n        tm = TaskMeta(\n            task_id=meta.get(\"task_id\", \"\"),\n            status=meta.get(\"status\", \"unknown\"),\n            mode=meta.get(\"mode\"),\n            workspace=meta.get(\"workspace\", \"\"),\n            ui_port=meta.get(\"ui_port\"),\n        )\n        self.tasks.append(tm)\n\n        extra_parts = []\n        if tm.mode:\n            extra_parts.append(f\"mode={tm.mode}\")\n        if tm.ui_port:\n            extra_parts.append(f\"port={tm.ui_port}\")\n        extra_str = \"; \".join(extra_parts)\n\n        # This string has [...] and \"mode=...\" so we MUST disable markup.\n        label = f\"{tm.task_id} [{tm.status}\"\n        if extra_str:\n            label += f\"; {extra_str}\"\n        label += \"]\"\n\n        self.append(ListItem(Static(label, markup=False)))\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.TaskList.on_list_view_selected","title":"<code>on_list_view_selected(event)</code>","text":"<p>When user selects a task row, send a semantic TaskSelected message.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def on_list_view_selected(self, event: ListView.Selected) -&gt; None:  # type: ignore[override]\n    \"\"\"When user selects a task row, send a semantic TaskSelected message.\"\"\"\n    if self.project_id is None:\n        return\n    task = self.get_selected_task()\n    if task is not None:\n        self.post_message(self.TaskSelected(self.project_id, task))\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.TaskDetails","title":"<code>TaskDetails(**kwargs)</code>","text":"<p>               Bases: <code>Static</code></p> <p>Bottom panel showing details for the currently selected task.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.current_project_id: str | None = None\n    self.current_task_id: str | None = None\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.TaskDetails.CopyDiffRequested","title":"<code>CopyDiffRequested(project_id, task_id, diff_type)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message sent when user requests to copy git diff.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def __init__(self, project_id: str, task_id: str, diff_type: str) -&gt; None:\n    super().__init__()\n    self.project_id = project_id\n    self.task_id = task_id\n    self.diff_type = diff_type  # \"HEAD\" or \"PREV\"\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.TaskDetails.on_button_pressed","title":"<code>on_button_pressed(event)</code>  <code>async</code>","text":"<p>Handle button presses for copy diff actions.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>async def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses for copy diff actions.\"\"\"\n    if not self.current_project_id or not self.current_task_id:\n        return\n\n    btn_id = event.button.id\n    diff_type = \"HEAD\" if btn_id == \"btn-copy-diff-head\" else \"PREV\"\n\n    self.post_message(\n        self.CopyDiffRequested(self.current_project_id, self.current_task_id, diff_type)\n    )\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.ProjectState","title":"<code>ProjectState</code>","text":"<p>               Bases: <code>Static</code></p> <p>Small panel summarizing infrastructure state for the active project.</p>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.StatusBar","title":"<code>StatusBar(**kwargs)</code>","text":"<p>               Bases: <code>Static</code></p> <p>Bottom status bar showing minimal key hints plus status text.</p> <p>This replaces Textual's default Footer so we can free horizontal space for real status messages instead of a long list of shortcuts. The shortcut hints are kept very small here because the primary shortcut hints already live in the ProjectActions button bar.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    # Initialize with an empty message; the App will populate this.\n    self.message: str = \"\"\n    self._update_content()\n</code></pre>"},{"location":"reference/codexctl/tui/widgets/#codexctl.tui.widgets.StatusBar.set_message","title":"<code>set_message(message)</code>","text":"<p>Update the status message area.</p> <p>The left side of the bar is reserved for a couple of always-on shortcut hints (\"q Quit\" and \"^P Palette\"); the rest of the line is dedicated to this message text.</p> Source code in <code>src/codexctl/tui/widgets.py</code> <pre><code>def set_message(self, message: str) -&gt; None:\n    \"\"\"Update the status message area.\n\n    The left side of the bar is reserved for a couple of always-on\n    shortcut hints (\"q Quit\" and \"^P Palette\"); the rest of the line is\n    dedicated to this message text.\n    \"\"\"\n\n    self.message = message\n    self._update_content()\n</code></pre>"}]}