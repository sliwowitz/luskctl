#!/usr/bin/env python3
"""
Blablador launcher for OpenCode.

Fetches models from Blablador's OpenAI-compatible API and runs OpenCode
with full permissions. Model selection can be done inside OpenCode.
"""

import argparse
import json
import os
import subprocess
from collections.abc import Iterable
from pathlib import Path
from urllib import request, error


DEFAULT_BASE_URL = "https://api.helmholtz-blablador.fz-juelich.de/v1"
# Preferred model - alias-huge provides the largest available model
PREFERRED_MODEL = "alias-huge"
# Fallback if preferred model is no longer available
FALLBACK_MODEL = "alias-code"


def _config_dir() -> Path:
    return Path.home() / ".blablador"


def _config_path() -> Path:
    return _config_dir() / "config.json"


def _load_api_key() -> str | None:
    api_key = os.environ.get("BLABLADOR_API_KEY")
    if api_key:
        return api_key
    cfg_path = _config_path()
    if not cfg_path.is_file():
        return None
    try:
        data = json.loads(cfg_path.read_text())
    except (OSError, json.JSONDecodeError):
        return None
    val = data.get("api_key")
    return val if isinstance(val, str) and val.strip() else None


def _fetch_models(base_url: str, api_key: str) -> list[str] | None:
    """Fetch available models from the API. Returns None on failure."""
    url = base_url.rstrip("/") + "/models"
    req = request.Request(
        url,
        headers={
            "Authorization": f"Bearer {api_key}",
            "Accept": "application/json",
        },
    )
    try:
        with request.urlopen(req, timeout=30) as resp:
            payload = json.loads(resp.read().decode("utf-8"))
    except (error.HTTPError, error.URLError, json.JSONDecodeError):
        return None

    items: Iterable[object] = []
    if isinstance(payload, dict):
        if isinstance(payload.get("data"), list):
            items = payload["data"]
        elif isinstance(payload.get("models"), list):
            items = payload["models"]

    models: list[str] = []
    for item in items:
        if isinstance(item, dict):
            model_id = item.get("id")
            if isinstance(model_id, str) and model_id:
                models.append(model_id)

    return sorted(set(models)) if models else None


def _build_config(base_url: str, api_key: str, model: str, models: list[str] | None) -> dict:
    model_map = {model: {"name": model}}
    if models:
        for mid in models:
            if isinstance(mid, str) and mid:
                model_map.setdefault(mid, {"name": mid})
    return {
        "$schema": "https://opencode.ai/config.json",
        "model": f"blablador/{model}",
        "provider": {
            "blablador": {
                "npm": "@ai-sdk/openai-compatible",
                "name": "Helmholtz Blablador",
                "options": {
                    "baseURL": base_url,
                    "apiKey": api_key,
                },
                "models": model_map,
            }
        },
        "permission": {
            "*": "allow",
        },
    }


def _opencode_config_path() -> Path:
    """Return the standard OpenCode config path."""
    return Path.home() / ".config" / "opencode" / "opencode.json"


def _load_opencode_config() -> dict | None:
    """Load existing OpenCode config if present."""
    config_path = _opencode_config_path()
    if not config_path.is_file():
        return None
    try:
        return json.loads(config_path.read_text(encoding="utf-8"))
    except (OSError, json.JSONDecodeError):
        return None


def _get_configured_models(config: dict | None) -> set[str]:
    """Extract model IDs from an existing blablador provider config."""
    if not config:
        return set()
    try:
        models = config.get("provider", {}).get("blablador", {}).get("models", {})
        return set(models.keys()) if isinstance(models, dict) else set()
    except (AttributeError, TypeError):
        return set()


def _write_opencode_config(config: dict) -> Path:
    """Write config to OpenCode's standard location."""
    config_path = _opencode_config_path()
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(json.dumps(config, indent=2), encoding="utf-8")
    return config_path


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="blablador",
        description="Run OpenCode against Helmholtz Blablador with full permissions.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "Examples:\n"
            "  blablador                # launch with preferred model\n"
            "  blablador --list-models  # list available models\n"
            "  blablador -- --help      # pass flags to opencode\n"
        ),
    )
    parser.add_argument("--list-models", action="store_true", help="List available models and exit")
    parser.add_argument(
        "--base-url",
        default=None,
        help=f"Override API base URL (default: {DEFAULT_BASE_URL})",
    )

    args, opencode_args = parser.parse_known_args()

    api_key = _load_api_key()
    if not api_key:
        raise SystemExit(
            "Missing BLABLADOR_API_KEY. Set it in the environment or write "
            f'{{"api_key": "..."}} to {_config_path()}.'
        )

    base_url = args.base_url or os.environ.get("BLABLADOR_BASE_URL") or DEFAULT_BASE_URL
    base_url = base_url.rstrip("/")

    # Fetch models from API
    fetched_models = _fetch_models(base_url, api_key)

    if args.list_models:
        if fetched_models:
            for model in fetched_models:
                print(model)
        else:
            raise SystemExit("Failed to fetch models from Blablador API")
        return 0

    # Load existing config and check if update is needed
    existing_config = _load_opencode_config()
    configured_models = _get_configured_models(existing_config)

    # Determine which model to use
    model = PREFERRED_MODEL
    if fetched_models and PREFERRED_MODEL not in fetched_models:
        print(
            f"Warning: Preferred model '{PREFERRED_MODEL}' is no longer available.\n"
            f"Falling back to '{FALLBACK_MODEL}'.\n"
            "Check for new upstream versions of luskctl to update the default model."
        )
        model = FALLBACK_MODEL

    # Update config if we have new models or no config exists
    if fetched_models:
        fetched_set = set(fetched_models)
        if fetched_set != configured_models:
            new_models = fetched_set - configured_models
            if new_models:
                print(f"New models available: {', '.join(sorted(new_models))}")
            config = _build_config(base_url, api_key, model, fetched_models)
            _write_opencode_config(config)
    elif not configured_models:
        # No fetched models and no existing config - create minimal config
        config = _build_config(base_url, api_key, model, [model])
        _write_opencode_config(config)

    cmd = ["opencode"] + opencode_args
    try:
        return subprocess.call(cmd)
    except FileNotFoundError:
        raise SystemExit("opencode not found. Rebuild the L1 CLI image to install it.")


if __name__ == "__main__":
    raise SystemExit(main())
