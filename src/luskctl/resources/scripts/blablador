#!/usr/bin/env python3
"""
Blablador launcher for OpenCode.

Fetches models from Blablador's OpenAI-compatible API, prompts for a model
selection, and runs OpenCode with full permissions inside the container.
"""


import argparse
import json
import os
import subprocess
import sys
from collections.abc import Iterable
from pathlib import Path
from urllib import request, error


DEFAULT_BASE_URL = "https://api.helmholtz-blablador.fz-juelich.de/v1"


def _config_dir() -> Path:
    return Path.home() / ".blablador"


def _config_path() -> Path:
    return _config_dir() / "config.json"


def _load_api_key() -> str | None:
    api_key = os.environ.get("BLABLADOR_API_KEY")
    if api_key:
        return api_key
    cfg_path = _config_path()
    if not cfg_path.is_file():
        return None
    try:
        data = json.loads(cfg_path.read_text())
    except (OSError, json.JSONDecodeError):
        return None
    val = data.get("api_key")
    return val if isinstance(val, str) and val.strip() else None


def _fetch_models(base_url: str, api_key: str) -> list[str]:
    url = base_url.rstrip("/") + "/models"
    req = request.Request(
        url,
        headers={
            "Authorization": f"Bearer {api_key}",
            "Accept": "application/json",
        },
    )
    try:
        with request.urlopen(req, timeout=30) as resp:
            payload = json.loads(resp.read().decode("utf-8"))
    except error.HTTPError as exc:
        raise SystemExit(f"Failed to fetch models ({exc.code}): {exc.reason}")
    except error.URLError as exc:
        raise SystemExit(f"Failed to fetch models: {exc.reason}")
    except json.JSONDecodeError:
        raise SystemExit("Failed to parse models response as JSON")

    items: Iterable[object] = []
    if isinstance(payload, dict):
        if isinstance(payload.get("data"), list):
            items = payload["data"]
        elif isinstance(payload.get("models"), list):
            items = payload["models"]

    models: list[str] = []
    for item in items:
        if isinstance(item, dict):
            model_id = item.get("id")
            if isinstance(model_id, str) and model_id:
                models.append(model_id)

    models = sorted({m for m in models})
    if not models:
        raise SystemExit("No models returned from Blablador /v1/models")
    return models


def _print_models(models: list[str]) -> None:
    for model in models:
        print(model)


def _choose_model(models: list[str]) -> str:
    if not sys.stdin.isatty():
        raise SystemExit("No TTY available. Pass --model or set BLABLADOR_MODEL.")
    print("Available Blablador models:")
    for idx, model in enumerate(models, start=1):
        print(f"  {idx:>2}) {model}")
    while True:
        choice = input(f"Select model [1-{len(models)}] (default 1): ").strip()
        if not choice:
            return models[0]
        if choice.isdigit():
            pick = int(choice)
            if 1 <= pick <= len(models):
                return models[pick - 1]
        if choice in models:
            return choice
        print("Invalid selection. Try again.")


def _build_config(base_url: str, api_key: str, model: str, models: list[str] | None) -> dict:
    model_map = {model: {"name": model}}
    if models:
        for mid in models:
            if isinstance(mid, str) and mid:
                model_map.setdefault(mid, {"name": mid})
    return {
        "$schema": "https://opencode.ai/config.json",
        "model": f"blablador/{model}",
        "provider": {
            "blablador": {
                "npm": "@ai-sdk/openai-compatible",
                "name": "Helmholtz Blablador",
                "options": {
                    "baseURL": base_url,
                    "apiKey": api_key,
                },
                "models": model_map,
            }
        },
        "permission": {
            "*": "allow",
        },
    }


def _opencode_config_path() -> Path:
    """Return the standard OpenCode config path (~/.config/opencode/opencode.json)."""
    return Path.home() / ".config" / "opencode" / "opencode.json"


def _load_opencode_config() -> dict | None:
    """Load existing OpenCode config if present."""
    config_path = _opencode_config_path()
    if not config_path.is_file():
        return None
    try:
        return json.loads(config_path.read_text(encoding="utf-8"))
    except (OSError, json.JSONDecodeError):
        return None


def _get_configured_models(config: dict | None) -> set[str]:
    """Extract model IDs from an existing blablador provider config."""
    if not config:
        return set()
    try:
        models = config.get("provider", {}).get("blablador", {}).get("models", {})
        return set(models.keys()) if isinstance(models, dict) else set()
    except (AttributeError, TypeError):
        return set()


def _get_configured_model(config: dict | None) -> str | None:
    """Get the currently configured model from config."""
    if not config:
        return None
    model = config.get("model", "")
    if isinstance(model, str) and model.startswith("blablador/"):
        return model[len("blablador/"):]
    return None


def _prompt_update_models(new_models: set[str], removed_models: set[str]) -> bool:
    """Prompt user whether to update the model list. Returns True if user wants to update."""
    if not sys.stdin.isatty():
        return False
    print("\nModel list has changed:")
    if new_models:
        print(f"  New models: {', '.join(sorted(new_models))}")
    if removed_models:
        print(f"  Removed models: {', '.join(sorted(removed_models))}")
    while True:
        choice = input("Update config with new model list? [Y/n]: ").strip().lower()
        if choice in ("", "y", "yes"):
            return True
        if choice in ("n", "no"):
            return False
        print("Please enter 'y' or 'n'.")


def _write_opencode_config(config: dict) -> Path:
    """Write config to OpenCode's standard location."""
    config_path = _opencode_config_path()
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(json.dumps(config, indent=2), encoding="utf-8")
    return config_path


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="blablador",
        description="Run OpenCode against Helmholtz Blablador with full permissions.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "Examples:\n"
            "  blablador                # prompt for a model, then launch\n"
            "  blablador --model <id>   # use a specific model\n"
            "  blablador --list-models  # list available models\n"
            "  blablador --update-models  # update the model list in config\n"
            "  blablador -- --help      # pass flags to opencode\n"
        ),
    )
    parser.add_argument("--model", "-m", help="Model ID from /v1/models")
    parser.add_argument("--list-models", action="store_true", help="List available models and exit")
    parser.add_argument(
        "--update-models", action="store_true", help="Update model list in config and exit"
    )
    parser.add_argument(
        "--base-url",
        default=None,
        help=f"Override API base URL (default: {DEFAULT_BASE_URL})",
    )

    args, opencode_args = parser.parse_known_args()

    api_key = _load_api_key()
    if not api_key:
        raise SystemExit(
            "Missing BLABLADOR_API_KEY. Set it in the environment or write "
            f'{{"api_key": "..."}} to {_config_path()}.'
        )

    base_url = args.base_url or os.environ.get("BLABLADOR_BASE_URL") or DEFAULT_BASE_URL
    base_url = base_url.rstrip("/")

    if args.list_models:
        models = _fetch_models(base_url, api_key)
        _print_models(models)
        return 0

    # Load existing config
    existing_config = _load_opencode_config()
    configured_models = _get_configured_models(existing_config)
    configured_model = _get_configured_model(existing_config)

    # Handle --update-models flag
    if args.update_models:
        fetched_models = _fetch_models(base_url, api_key)
        model = configured_model or fetched_models[0]
        config = _build_config(base_url, api_key, model, fetched_models)
        _write_opencode_config(config)
        print(f"Updated config with {len(fetched_models)} models.")
        return 0

    # Determine model to use
    model = args.model or os.environ.get("BLABLADOR_MODEL") or configured_model
    fetched_models: list[str] | None = None

    # Fetch models from API
    try:
        fetched_models = _fetch_models(base_url, api_key)
    except SystemExit:
        # If we have an existing config and model, continue without fresh model list
        if model and configured_models:
            fetched_models = sorted(configured_models)
        else:
            raise

    # Check for model list changes and prompt to update
    if fetched_models and configured_models:
        fetched_set = set(fetched_models)
        new_models = fetched_set - configured_models
        removed_models = configured_models - fetched_set
        if new_models or removed_models:
            if _prompt_update_models(new_models, removed_models):
                config = _build_config(base_url, api_key, model or fetched_models[0], fetched_models)
                _write_opencode_config(config)
                print("Config updated.")

    # If no model selected yet, prompt user
    if not model:
        if not fetched_models:
            raise SystemExit("No models available. Pass --model to continue.")
        model = _choose_model(fetched_models)

    # Write or update config if needed
    if not configured_models or model != configured_model:
        config = _build_config(base_url, api_key, model, fetched_models)
        _write_opencode_config(config)

    cmd = ["opencode"] + opencode_args
    try:
        return subprocess.call(cmd)
    except FileNotFoundError:
        raise SystemExit("opencode not found. Rebuild the L1 CLI image to install it.")


if __name__ == "__main__":
    raise SystemExit(main())
