#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2025-2026 Jiri Vyskocil <jiri@vyskocil.com>
#
# SPDX-License-Identifier: Apache-2.0

"""
Mistral Model Synchronization Tool

This script checks for new Mistral models and alerts users when updates are available.
It can be integrated into the CLI container's bashrc to provide automatic notifications.
"""

import json
import os
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Any

import requests

# Configuration constants
CACHE_FILENAME = "mistral-models.txt"
CONFIG_FILENAME = "config.toml"
ENV_FILENAME = ".env"
MISTRAL_MODELS_URL = "https://api.mistral.ai/v1/models"

# File paths
HOME_DIR = Path.home()
VIBE_DIR = HOME_DIR / ".vibe"
CACHE_PATH = VIBE_DIR / CACHE_FILENAME


def get_api_key() -> str | None:
    """Get Mistral API key from environment or .env file."""
    # Check environment variable first
    api_key = os.environ.get("MISTRAL_API_KEY")
    if api_key:
        return api_key.strip()

    # Check .env file
    env_path = VIBE_DIR / ENV_FILENAME
    if env_path.exists():
        try:
            with open(env_path, encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    if line.startswith("MISTRAL_API_KEY="):
                        # Remove quotes if present
                        value = line.split("=", 1)[1].strip()
                        return value.strip("\"'")
        except Exception as e:
            print(f"Warning: Could not read .env file: {e}", file=sys.stderr)

    return None


def fetch_models(api_key: str) -> list[str]:
    """Fetch available models from Mistral API."""
    try:
        headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}

        response = requests.get(MISTRAL_MODELS_URL, headers=headers, timeout=30)
        response.raise_for_status()

        data = response.json()
        models = []

        if isinstance(data.get("data"), list):
            for model in data["data"]:
                if isinstance(model.get("id"), str):
                    models.append(model["id"])

        return sorted(models)

    except requests.RequestException as e:
        print(f"Error fetching models from Mistral API: {e}", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error parsing API response: {e}", file=sys.stderr)
        sys.exit(1)


def read_cache(cache_path: Path) -> list[str]:
    """Read cached model list from file."""
    if not cache_path.exists():
        return []

    try:
        with open(cache_path, encoding="utf-8") as f:
            lines = []
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    lines.append(line)
        return lines
    except Exception as e:
        print(f"Warning: Could not read cache file: {e}", file=sys.stderr)
        return []


def write_cache(cache_path: Path, models: list[str]) -> None:
    """Write model list to cache file."""
    try:
        # Ensure directory exists
        cache_path.parent.mkdir(parents=True, exist_ok=True)

        # Write cache with timestamp header
        header = f"# Generated by mistral-model-sync on {datetime.now().isoformat()}"
        content = "\n".join([header] + models + [""])

        with open(cache_path, "w", encoding="utf-8") as f:
            f.write(content)

        # Update file timestamp
        cache_path.touch()

    except Exception as e:
        print(f"Error writing cache file: {e}", file=sys.stderr)
        sys.exit(1)


def find_config_path() -> Path | None:
    """Find Mistral config file in local or home directory."""
    # Check local directory first
    local_path = Path.cwd() / ".vibe" / CONFIG_FILENAME
    if local_path.exists():
        return local_path

    # Check home directory
    home_path = VIBE_DIR / CONFIG_FILENAME
    if home_path.exists():
        return home_path

    return None


def read_config_models(config_path: Path) -> set[str]:
    """Read model references from config file."""
    models = set()

    try:
        with open(config_path, encoding="utf-8") as f:
            content = f.read()

        # Simple parsing for model references
        # Look for patterns like: model = "model-name"
        # or models = ["model1", "model2"]

        import re

        # Single model pattern
        single_model_matches = re.findall(r'model\s*=\s*"([^"]+)"', content)
        for model in single_model_matches:
            models.add(model)

        # Array of models pattern
        array_matches = re.findall(r"models\s*=\s*\[([^\]]+)\]", content)
        for match in array_matches:
            # Extract quoted strings from the array
            array_models = re.findall(r'"([^"]+)"', match)
            for model in array_models:
                models.add(model)

    except Exception as e:
        print(f"Warning: Could not read config file: {e}", file=sys.stderr)

    return models


def check_cache_age(cache_path: Path, min_age_seconds: int | None = None) -> bool:
    """Check if cache is recent enough to skip API call."""
    if min_age_seconds is None or not cache_path.exists():
        return False

    try:
        cache_time = cache_path.stat().st_mtime
        current_time = time.time()
        age_seconds = current_time - cache_time

        return age_seconds < min_age_seconds
    except Exception:
        return False


def parse_args() -> dict[str, Any]:
    """Parse command line arguments."""
    import argparse

    parser = argparse.ArgumentParser(description="Mistral Model Synchronization Tool")

    parser.add_argument(
        "--min-age-seconds", type=int, help="Skip fetching when cache is newer than N seconds"
    )

    parser.add_argument(
        "--min-age-hours", type=int, help="Skip fetching when cache is newer than N hours"
    )

    parser.add_argument(
        "--ack",
        "--acknowledge",
        action="store_true",
        help="Update the cache with the latest list from the API",
    )

    args = parser.parse_args()

    # Convert hours to seconds if provided
    min_age_seconds = None
    if args.min_age_seconds is not None:
        min_age_seconds = args.min_age_seconds
    elif args.min_age_hours is not None:
        min_age_seconds = args.min_age_hours * 3600

    return {"min_age_seconds": min_age_seconds, "acknowledge": args.ack or args.acknowledge}


def main() -> int:
    """Main function."""
    args = parse_args()
    min_age_seconds = args["min_age_seconds"]
    acknowledge = args["acknowledge"]

    # Check if we should skip API call due to cache age
    if min_age_seconds is not None and check_cache_age(CACHE_PATH, min_age_seconds):
        return 0

    # Get API key
    api_key = get_api_key()
    if not api_key:
        print("Error: Missing MISTRAL_API_KEY (env or ~/.vibe/.env).", file=sys.stderr)
        return 1

    # Fetch models from API
    api_models = fetch_models(api_key)
    api_set = set(api_models)

    # Check if we're just acknowledging
    if acknowledge:
        write_cache(CACHE_PATH, api_models)
        print("Cache updated with latest model list.")
        return 0

    # Read cached models
    cached_models = read_cache(CACHE_PATH)
    cached_set = set(cached_models)

    # If no cache, create one and exit
    if not cached_models:
        write_cache(CACHE_PATH, api_models)
        return 0

    # Find config file and read configured models
    config_path = find_config_path()
    config_models = set()
    if config_path:
        config_models = read_config_models(config_path)

    # Find differences
    new_models = [model for model in api_models if model not in cached_set]
    missing_config_models = [model for model in config_models if model not in api_set]

    # If no changes, update cache timestamp and exit
    if not new_models and not missing_config_models:
        CACHE_PATH.touch()
        return 0

    # Print summary
    print("Mistral model sync detected changes.")

    if new_models:
        print(f"\nNew models ({len(new_models)}):")
        for model in new_models:
            print(f"  - {model}")

    if missing_config_models:
        print(f"\nModels missing from API but referenced in {config_path.name}:")
        for model in missing_config_models:
            print(f"  - {model}")

    print(f"\nPlease run '{sys.argv[0]} --ack' to acknowledge and update the cache.")

    return 1  # Return non-zero to indicate changes detected


if __name__ == "__main__":
    sys.exit(main())
